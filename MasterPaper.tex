%%
% 下のコメント欄は卒論執筆時の森がイキって書いたものです。
% 修論執筆時の森が代わりに謝罪いたします。
% 温かい目で見守ってあげてください。
%
% また、修論執筆時にはTeXstudioで、またDockerを用いて執筆しています。
% 上記の手法は平木場くんから教えていただきました。
% 参考: https://qiita.com/Shitimi_613/items/9706d57fb7bc17cbed0e
%

%%
% モダンなLaTeXを書きたい？
% そしたら僕の考えた最強のtexファイルを見てくれ
%
% 注意！
% このLaTeXをPDFに変換するためには、普通とはちょっと違う方法を使うよ
% コマンド上では
%   $ ptex2pdf -u -l GraduatePaper.tex
% で変換してね
% もしptex2pdfコマンドが無かったら、
%   $ uplatex GraduatePaper.tex
%   $ dvipdfmx GraduatePaper.dvi
% でうまくいくかも(未確認)
%
% え、TeXworksで使いたいって？
% そしたら、TeXworksの編集メニュー -> 設定を開く
% タイプセットタブの下の方にあるタイプセットの方法の右下の＋ボタンを選択する
% 名前: uplatex(ptex2pdf)
% プログラム: ptex2pdf
% 引数: -l
%       -u
%       -ot
%       $synctexoption
%       $fullname
% として保存して、TeXworks実行ボタン右のコンボボックスのuplatex(ptex2pdf)を選択して変換だ！
%


%%
% 今時jarticleやjbook使ってる人いる？時代はjsarticleかjsbookだよ
% ついでに言うと、uplatexってのはplatexの上位互換、これを使わないなんて旧世代だよね
%
\documentclass[uplatex, report, a4j, 10pt]{jsbook}


%%
% パッケージ群
%
\usepackage{packages/miyazaki-u-paper}   % 宮崎大学工学部の卒論の基本(片山先生作)を、僕がちょっと書き換えちゃった(テヘッ
\usepackage{enumitem}           % enumerate？古い古い
\usepackage[dvipdfmx]{graphicx} % 当然dvipdfmなんて使ってないよね
\usepackage[dvipdfmx]{color}    % listingsを使うときにはこれも必須、dvipdfmxを変えちゃうとgraphicxのdvipdfmxも変わるよ
\usepackage{listings, packages/jlisting} % コードを埋め込むなら必須
\usepackage{txfonts}            % フォントといえばやっぱりtxfonts、今はnewtxってのもあるらしい
\usepackage{verbatim}           % コメントアウトしてくれる便利なプリアンブルが使える \begin{comment} ... \end{comment}
\usepackage[hdivide={21mm, , 21mm}, vdivide={30mm, , 25mm}]{geometry} % スタイルを少し変えたくても\hoffset, \voffsetは使わないでね
\usepackage[dvipdfmx]{hyperref} % リンクを付けてくれる。
\usepackage{pxjahyper}          % リンクを付けてくれる（日本語）
\usepackage[htt]{hyphenat}      % textttをハイフネーションしてくれる。
\usepackage{multirow}


%%
% font周りのwarningを消す。
% https://www.semipol.de/2018/06/12/latex-best-practices.html#filtering-warnings
%
\usepackage{silence}% http://ctan.org/pkg/silence
\WarningFilter{latexfont}{Font shape}
\WarningFilter{latexfont}{Some font shapes}

%\RequirePackage[l2tabu, orthodox]{nag} % これを入れると、古いコマンドを警告してくれる！なお完全には消せなかった模様
\newcommand\todo[1]{\PackageWarning{Todo}{Detection TODO:#1}\textcolor{red}{(TODO:#1)}}

%%
% マクロの定義
%
\newcommand\ttt[1]{\texttt{#1}}
\newcommand{\tool}{BWDM}
\newcommand{\toolFullName}{Verification tool for Vienna Development Method}

\renewcommand{\lstlistingname}{コード}
\lstset{
  language={Java},
  frame=tlBR,%フレーム線の指定、上右下左の順、大文字は二重線
%  frameround=tttt,%角の指定、右上|右下|左下|左上の順、tは丸角、fは四角
  framesep=5pt,%本文からframeまでの間隔
  framerule=.2pt,%線の太さ
%  rulecolor={\color[gray]},%線の色
%  backgroundcolor={\color[gray]{.9}},%背景色の指定
  basicstyle={\scriptsize\ttfamily \color[gray]{.15}},%書体の指定、この場合は7ptのタイプライタ体
  identifierstyle={\ttfamily},%識別子の書体
  keywordstyle={\ttfamily \color[cmyk]{0,1,0,0}},%言語ワードの書体
  stringstyle={\scriptsize\ttfamily \color[rgb]{0,0,1}},%文字列リテラルの書体
  commentstyle={\itshape \color[cmyk]{1,0,1,0}},%コメントの書体
  numberstyle={\scriptsize},%行番号の書式
  stepnumber=1,%行番号のステップ間隔
  numbers=left,%行番号の位置
  numbersep=1em,%本文との間隔
  breaklines=true,%改行の設定
  xleftmargin=0zw,
  xrightmargin=0zw,
  columns=[l]{fullflexible},
  lineskip=-0.5zw,
  morecomment={[s][{\color[cmyk]{1,0,0,0}}]{/**}{*/}},
  floatplacement=t,
  classoffset=1,
  showstringspaces=false,%空行の表示
%  breakatwhitespace=true,
%  tabsize=5,
}

\lstdefinestyle{interfaces}{
  float=tp,
  floatplacement=tbp,
  abovecaptionskip=-5pt
}

%%
% miyazaki-u-paper.sty用設定値
%
\degree{m} % Graduateのg or Masterのm
\figurenumbering{f} % 図目次を付ける場合はt (真) を持つ真偽値を引数に取る関数
\tablenumbering{f} % 表目次を付ける場合はt (真) を持つ真偽値を引数に取る関数
\title{VDM++仕様を対象としたテストケース \\ 自動生成ツールBWDMにおける \\ ペアワイズ法とドメイン分析テストの \\ 適用のための機能拡張}
\author{平木場 風太}
\nendo{1} % 年度
\advisor{片山 徹郎 教授} % 修論では無視する
\major{工学専攻 機械・情報系コース 情報システム工学分野}



\begin{document}
\maketitle

\preface{概要}
\begin{comment}
社会におけるソフトウェアの重要性は高まっており、ソフトウェアのバグが社会にもたらす影響も近年では甚大なものとなっている。
近年、ソフトウェアにバグが混入する原因の排除を目的として、形式仕様記述言語を用いた仕様記述が重要視されてきている。

一方で、人手によるテストケースの設計には手間と時間がかかる問題を解決するため、
形式仕様記述言語の一つであるVDM++(Vienna Development Method)仕様を対象としたテストケース自動生成を目的としたツールBWDM(Boundary Value/Vienna Develop Method)
を立山らが開発した。
既存のBWDMには、境界値分析時にすべての組合せを用いてテストケースを生成するため、組合せ爆発を起こす可能性がある問題、および、複数の変数を含む条件式を持つ関数のテストケースを生成できない問題が存在する。
また、その他に3つの問題点が存在する。
そこで、本研究では、上記5つの問題点を解決することを目的として、BWDMの拡張を行った。

まずは、ペアワイズ法を適用したテストケース生成ができるようにBWDMを拡張した。
これにより、境界値分析結果から生成するテストケース数が組合せ爆発を起こす可能性を排除することができ、テスト工程の作業効率化を見込めると考えられる。
次に、ドメイン分析テストのためのテストケース生成ができるようにBWDMを拡張した。
これにより、複数の変数を含む条件式を持つVDM++仕様のテストケース生成ができるようになった。
また、ドメイン分析テストのためのテストケース生成に要した時間を人手と比較検証した結果、18分程の時間短縮を確認できた。
加えて、その他3つの問題点を解決するため、BWDMにおける構文解析部の抽象構文木解析処理を修正し、BWDMを拡張した。
これにより、BWDMの対応範囲が広がり、より多くのVDM++仕様のテストケース生成が可能となった。

以上により、拡張したBWDMは、さらに有用性が向上したと言える。
また、より幅広くテストケース生成ができるようになったことで、BWDMのテストケース生成効率が向上したと言える。
\end{comment}

社会におけるソフトウェアの重要性は高まっており、ソフトウェアのバグが社会にもたらす影響も近年では甚大なものとなっている。
ソフトウェアにバグが混入する原因の1つとして、上流工程のソフトウェア設計段階において、自然言語を一般的に用いていることが挙げられる。
自然言語は元来、曖昧さを含んでいる。
そのため、プログラマが、仕様書上の表記を、仕様書の作成者が本来意図していない意味で捉えてしまうことが起こる。
プログラマが、仕様書の本来の意図から外れた認識に基づいて実装を行った結果、ソフトウェアにバグが混入されてしまう。

この問題を解決するための1つの方法として、
形式手法を用いた上流工程でのソフトウェア設計が挙げられる。
また、形式仕様記述言語の1つにVDM++(Vienna Development Method)がある。
近年、形式仕様記述言語を用いた仕様記述が重要視されてきている。

一方で、作成したソフトウェアにはテストが必要であるが、人手によるテストケースの設計には手間と時間がかかる。
そのため、VDM++仕様を対象としたテストケース自動生成を目的としたツールBWDM(Boundary Value/Vienna Develop Method)
を立山らが開発した。

既存のBWDMは、VDM++仕様を入力として、境界値分析と記号実行を行い、テストケースを自動生成する。
自動生成したテストケースによって、境界値テストと、if-then-else式の構造認識に基づいたテストを実施できる。

しかし、既存のBWDMには、以下の5つの問題点がある。

\begin{enumerate}[label=(\alph*)]
  \item 境界値分析時にすべての組合せを用いてテストケースを生成するため、組合せ爆発を起こす可能性がある
  \item 複数の変数を含む条件式を持つ関数のテストケースを生成できない
  \item 1つの関数しかテストケースを生成できない
  \item 定数定義ブロック内の定義を含む関数を含む仕様のテストケースを生成できない
  \item 操作のテストケースを生成できない
\end{enumerate}

そこで、本研究では、BWDMの有用性の向上を目的として、BWDMの拡張を行う。
具体的には、上記5つの問題点を解決する。
また、拡張後のBWDMの名称を、\tool{}(\toolFullName{})に変更する。

まず、本研究では、既存のBWDMにおける、境界値分析結果から生成するテストケース数が組合せ爆発を起こす可能性の排除を目的として、BWDMの拡張を行う。
拡張したBWDMは、VDM++仕様に対して境界値分析を行い、ペアワイズ法を適用し、テストケースを自動生成する。
これにより、境界値分析結果から生成するテストケース数が組合せ爆発を起こす可能性を排除することができたため、テスト工程の作業効率化を見込めると考えられる。

次に、本研究では、既存のBWDMにおける、複数の変数を含む条件式を持つ仕様に対してテストケース生成ができないという問題の解決を目的として、ドメイン分析テストのためのテストケース生成を、BWDMに適用する拡張を行う。
まず、ドメイン分析部を追加し、onポイント、offポイント、inポイント、outポイントを生成できるようにする。
また、SMTソルバを用いて、充足可能性問題を解けるようにする。
次に、テストケースに、正常系判定値、着目条件式、そして着目変数の情報を含めるために、テストケース生成部を拡張する。
拡張したBWDMは、複数の変数を含む条件式を持つVDM++仕様の構文解析と、ドメイン分析テストのためのテストケース生成ができるようになったことを確認した。
また、ドメイン分析テストのためのテストケース生成に要した時間を人手と比較検証した結果、18分程の時間短縮を確認できた。

加えて、本研究では、既存のBWDMにおける、
1つの関数しかテストケースを生成できないという問題、
定数定義ブロック内の定義を含む関数を含む仕様のテストケースを生成できないという問題、
操作のテストケースを生成できないという問題の解決を目的として、
BWDMにおける構文解析部の抽象構文木解析処理を修正し、BWDMを拡張する。
これにより、BWDMの対応範囲が広がったため、より多くのVDM++仕様のテストケース生成が可能となった。

以上により、本研究で行った拡張によって、既存のBWDMの持つ5つの問題点を解決し、BWDMの有用性が向上したと言える。
また、BWDMがテストケースを自動生成できるVDM++仕様の構文が増えたことにより、テストケース作成作業の自動化率が向上するため、テスト工程の作業効率が向上したと言える。

%%
% 本文
%
% はじめに
\chapter{はじめに}\label{cha:Introduction}
社会におけるソフトウェアの重要性は高まっており、ソフトウェアのバグが社会にもたらす影響も近年では甚大なものとなっている\cite{mizuho}。
ソフトウェアにバグが混入する原因の1つとして、上流工程のソフトウェア設計段階において、自然言語を一般的に用いていることが挙げられる\cite{seminarFormalMethod}。
自然言語は元来、曖昧さを含んでいる。
そのため、プログラマが、仕様書上の表記を、仕様書の作成者が本来意図していない意味で捉えてしまうことが起こる。
プログラマが、仕様書の本来の意図から外れた認識に基づいて実装を行った結果、ソフトウェアにバグが混入されてしまう。

この問題を解決するための1つの方法として、
形式手法(Formal Methods)\cite{programSpecification}を用いた上流工程でのソフトウェア設計が挙げられる。
また、形式仕様記述言語の1つにVDM++(Vienna Development Method)がある\cite{vdm_manual}。
近年、形式仕様記述言語を用いた仕様記述が重要視されてきている\cite{seminarFormalMethod}。

一方で、作成したソフトウェアにはテストが必要であるが、人手によるテストケースの設計には手間と時間がかかる。
そのため、VDM++仕様を対象としたテストケース自動生成を目的としたツールBWDM(Boundary Value/Vienna Develop Method)
を、立山らが開発した\cite{tachiyama8, tachiyama6}。

既存のBWDMは、VDM++仕様を入力として、境界値分析と記号実行を行い、テストケースを自動生成する。
自動生成したテストケースによって、境界値テストと、if-then-else式の構造認識に基づいたテストを実施できる。

しかし、既存のBWDMには、以下の5つの問題点がある。

\begin{enumerate}[label=(\alph*)]
  \item\label{problem:1} 境界値分析時にすべての組合せを用いてテストケースを生成するため、組合せ爆発を起こす可能性がある
  \item\label{problem:2} 複数の変数を含む条件式を持つ関数のテストケースを生成できない
  \item\label{problem:3} 1つの関数しかテストケースを生成できない
  \item\label{problem:4} 定数定義ブロック内の定義を含む関数を含む仕様のテストケースを生成できない
  \item\label{problem:5} 操作のテストケースを生成できない
\end{enumerate}

そこで、本研究では、BWDMの有用性の向上を目的として、BWDMの拡張を行う\cite{hirakoba1, hirakoba2, hirakoba3, hirakoba4, hirakoba5,bwdm}。
具体的には、既存のBWDMが持つ、上記5つの問題点を解決する。
また、拡張後のBWDMの名称を、\tool{}(\toolFullName{})に変更する。

まず、本研究では、BWDMが組合せ爆発を起こす可能性(問題\ref{problem:1})の排除を目的として、BWDMによるテストケース生成にペアワイズ法を適用し、BWDMを拡張する。
ペアワイズ法とは、組合せテストの総数を減らした上で、効果的なテストを行う方法である\cite{pairwise}。
ソフトウェアについて、3つ以上の因子の組合せで発生する欠陥は、ほとんど存在しないことが知られている\cite{over3fact}。
したがって、組合せテストは2つの因子の組合せに対して効果的である。
(3つ以上の因子で発生している欠陥を見つけるには、他の方法でテストする必要がある。)
そして、2つの因子のみの組合せをテストする手法のことをペアワイズ法と呼ぶ。
ペアワイズ法を適用するに当たって、Microsoft社が開発したPICT(Pairwise Independent Combinatorial Testing tool)\cite{pict}を利用する。
PICTはCLI(Command Line Interface)ツールであるが、API(PICTライブラリと呼称する)も提供しており、C++から利用できる。
しかし、既存のBWDMはJavaで記述しており、PICTライブラリを呼び出すことができない。
そこで、PICTとBWDMを接続するためのインタフェースとして、pict4javaを開発する\cite{pict4java}。
そして、既存のBWDMにpict4javaを埋め込むことで、BWDMを拡張する。

次に、本研究では、既存のBWDMにおける、複数の変数を含む条件式を持つ仕様に対してテストケース生成ができないという問題(問題\ref{problem:2})の解決を目的として、BWDMによるテストケース生成にドメイン分析テストのためのテストケース生成手法を適用し、BWDMを拡張する。
ドメイン分析テストとは、境界値分析において、複数の変数を含む条件式を持つ関数をテストする方法である\cite{izon}\cite{istqb}。
ここで、本研究における、複数の変数を含む条件式とは、片方の辺にのみ複数の変数が含まれ、もう片方の辺は定数のみの条件式を指すこととする。
すなわち、両辺に変数を含む条件式を持つ仕様は、本研究の対象としない。

加えて、本研究では、既存のBWDMにおける、
1つの関数しかテストケースを生成できないという問題(問題\ref{problem:3})、
定数定義ブロック内の定義を含む関数を含む仕様のテストケースを生成できないという問題(問題\ref{problem:4})、
操作のテストケースを生成できないという問題(問題\ref{problem:5})の解決を目的として、
BWDMにおける構文解析部の抽象構文木解析処理を修正し、BWDMを拡張する。

以下、本論文の構成は次のとおりである。

第\ref{cha:Preparation}章では、\tool{}を実装するために必要となる前提知識について説明する。

第\ref{cha:Exist}章では、既存の\tool{}について説明する。

第\ref{cha:Extended}章では、拡張した\tool{}について説明する。

第\ref{cha:Indication}章では、適用例を用いて、拡張した\tool{}が正しく動作することを検証する。

第\ref{cha:Evaluation}章では、拡張した\tool{}について考察する。

第\ref{cha:Conclusion}章では、本研究のまとめと今後の課題を示す。



% 研究の準備
\chapter{研究の準備}\label{cha:Preparation}

本章では、\tool{}を拡張するにあたり、必要となる前提知識を説明する。

\section{VDM++}
形式手法の1つにVDM(Vienna Development Method)\cite{vdm}がある。
1970年代にウィーンのIBM研究所で考案され、1990年代前半にかけて開発された。
1996年には形式仕様記述言語VDM-SLがISO標準となっている\cite{iso96}。
VDM++は、VDM-SLにオブジェクト指向拡張を施した形式仕様記述言語である。
本研究で拡張するBWDMはこのVDM++で記述された仕様のテストケースを生成する。
また、本研究では、Overture Projectが発行しているVDM-10 Language Manualで定義されているVDM++を対象とする\cite{vdm_manual}。

VDMには、VDMTools\cite{vdmtools}やOverture IDE\cite{overture}などの支援ツールが揃っており、
仕様の検証などを他の形式手法に比べ比較的行いやすいという利点がある。

VDM++では、関数や操作の定義を定義ブロック(\ttt{definition block})で行う。
それぞれの定義と、各定義に対応する日本語での呼び方を、表\ref{tab:vdm_definition_japanese}に示す。
\begin{table}[t]
  \begin{center}
    \caption{VDM++における定義および各定義に対応する日本語での呼び方}
    \label{tab:vdm_definition_japanese}
    \begin{tabular}{c|c}
      VDM++における定義                   & 日本語での呼び方     \\
      \hline
      \hline
      \ttt{type definitions}              & 型定義               \\ \hline
      \ttt{state definition}              & 状態定義             \\ \hline
      \ttt{value definitions}             & 定数定義             \\ \hline
      \ttt{function definitions}          & 関数定義             \\ \hline
      \ttt{operation definitions}         & 操作定義             \\ \hline
      \ttt{instance variable definitions} & インスタンス変数定義 \\ \hline
      \ttt{synchronization definitions}   & 同期定義             \\ \hline
      \ttt{thread definitions}            & スレッド定義         \\ \hline
      \ttt{traces definitions}            & トレース定義
    \end{tabular}
  \end{center}
\end{table}

また、本研究で拡張するBWDMは、表\ref{tab:vdm_definition_japanese}における、定数定義、操作定義、インスタンス変数定義に、新たに対応する。
詳細を、以下に示す。

\begin{itemize}
  \item 定数定義\\
        定数定義は、プログラミングにおける定数を表す。
        定義した定数は、関数定義、操作定義で利用できる。
        拡張するBWDMは、定数定義に対応することで、関数定義、または、操作定義内で定数を利用できる。
        ただし、本研究で定義の対象とする定数の型は、\ttt{int}、\ttt{nat}、\ttt{nat1}のいずれかとする。
  \item 操作定義\\
        操作定義は、プログラミングにおけるメソッドを表す。
        定義した操作は、同クラス内のインスタンス変数を参照できる。
        拡張するBWDMは、操作定義に対応することで、if-then-else式の構造認識に基づいたテストを実施するためのテストケースを自動生成する。
        ただし、本研究で定義の対象とする操作内で使用する型は、\ttt{int}、\ttt{nat}、\ttt{nat1}と\ttt{sec of char}(戻り値のみ)のいずれかとする。
        また、事前条件と事後条件には対応しない。
  \item インスタンス変数定義\\
        インスタンス変数定義は、プログラミングにおけるフィールドを表す。
        定義した定数は、関数定義、操作定義で利用できる。
        拡張するBWDMは、インスタンス変数定義に対応することで、操作定義内でインスタンス変数を利用できる。
        ただし、本研究で定義の対象とするインスタンス変数の型は、\ttt{int}、\ttt{nat}、\ttt{nat1}のいずれかとする。
\end{itemize}

\section{VDMJ}\label{sec:vdmj}
VDMJ\cite{vdmj}は、Nick Battle氏が開発しているVDMの支援ツールである。
GNU GPL3ライセンスでソースコードを公開しているVDM支援ツールであり、構文解析器、型チェッカー、デバッガなどの機能を持つ。
VDMを用いた開発を支援するIDEであるOverture Tool\cite{overture}の内部にも用いられている。

本研究では、VDM++仕様の静的解析において、VDMJの字句解析機能と構文解析機能を利用する。

\begin{table}[t]
  \begin{center}
    \caption{VDM++における定義および定義に対応するVDMJでの呼び方}
    \label{tab:vdmj_definition_name}
    \begin{tabular}{c|c}
      VDM++における定義    & VDMJでの呼び方     \\
      \hline
      \hline
      関数定義             & explicit function  \\ \hline
      操作定義             & explicit operation \\ \hline
      定数定義             & value              \\ \hline
      インスタンス変数定義 & instance variable
    \end{tabular}
  \end{center}
\end{table}

また、本研究で利用するVDMJのクラスを、以下に示す。

\begin{itemize}
  \item 抽象クラス\ttt{VDMJ::TCDefinition}\\
        VDM++における各定義ブロックを表す抽象クラスである。フィールド\ttt{name}の値は定義名を示す。メソッド\ttt{kind()}を実行することで、定義の種類を取得できる。
        VDM++における定義の種類を、表\ref{tab:vdmj_definition_name}に示す。
  \item クラス\ttt{VDMJ::TCExplicitFunctionDefinition}\\
        VDM++における関数定義ブロックfunctions内にある定義を表すクラスである。
  \item クラス\ttt{VDMJ::TCExplicitOperationDefinition}\\
        VDM++における操作定義ブロックoperationsにある定義を表すクラスである。
  \item クラス\ttt{VDMJ::TCValueDefinition}\\
        VDM++における定数定義ブロックvaluesにある定義を表すクラスである。
  \item クラス\ttt{VDMJ::TCInstanceVariableDefinition}\\
        VDM++におけるインスタンス変数定義ブロックinstance variablesにある定義を表すクラスである。
\end{itemize}

\section{因子と水準}\label{sec:factor_and_level}
\begin{table}[tp]
  \begin{center}
    \caption{性別と年齢を入力として出力が決定される関数の因子と水準}
    \label{tab:factor_level}
    \begin{tabular}{c|c|c}
      因子                  & 水準               & 因子の取り得る値 \\
      \hline
      \hline
                            &                    & 男性             \\  \cline{3-3}
      性別                  & 3                  & 女性             \\ \cline{3-3}
                            &                    & その他           \\ \hline
      \multirow{2}{*}{年齢} & \multirow{2}{*}{2} & 20歳未満         \\ \cline{3-3}
                            &                    & 20歳以上         \\ \hline
                            &                    & 日本             \\  \cline{3-3}
      国籍                  & 3                  & アメリカ         \\ \cline{3-3}
                            &                    & その他           \\ \hline
    \end{tabular}
  \end{center}
\end{table}

因子とは、テスト対称に影響を与える要因である。本研究においては、関数、または、操作内の変数を意味する。
水準とは、因子の取り得る値の数である。本研究においては、関数、または、操作内の変数が取り得る値の数を意味する\cite{factor_level}。

例えば、性別\{``男性'', ``女性'', ``その他''\}と年齢\{``20歳未満'', ``20歳以上''\}、国籍\{``日本'', ``アメリカ'', ``その他''\}を入力として出力が決定される関数の場合の因子と水準を、表\ref{tab:factor_level}に示す。


\section{ペアワイズ法}
\begin{table}[tp]
  \begin{center}
    \caption{性別と年齢と国籍を入力として出力が決定される関数のペアワイズ法を用いた場合の組合せの例}
    \label{tab:example_pairwise}
    \begin{tabular}{c|c|c}
      性別   & 年齢     & 国籍     \\
      \hline
      \hline
      女性   & 20歳以上 & 日本     \\ \hline
      その他 & 20歳未満 & 日本     \\ \hline
      女性   & 20歳未満 & その他   \\ \hline
      その他 & 20歳以上 & その他   \\ \hline
      男性   & 20歳以上 & アメリカ \\ \hline
      女性   & 20歳未満 & アメリカ \\ \hline
      その他 & 20歳未満 & アメリカ \\ \hline
      男性   & 20歳未満 & 日本     \\ \hline
      男性   & 20歳以上 & その他   \\
    \end{tabular}
  \end{center}
\end{table}

ペアワイズ法とは、組合せテストの総数を減らした上で、効果的なテストを行う方法である\cite{pairwise}。
ソフトウェアについて、3つ以上の因子の組合せで発生する欠陥は、ほとんど存在しないことが知られている\cite{over3fact}。
したがって、組合せテストは2つの因子の組合せに対して効果的である。
(3つ以上の因子で発生している欠陥を見つけるには、他の方法でテストする必要がある。)
狭義においては、2つの因子のみの組合せをテストする手法のことをペアワイズ法と呼ぶ。

ペアワイズ法の例を示す。
\ref{sec:factor_and_level}節の例の関数は、因子が3で水準が(3, 2, 3)である。
この関数の総組合せでテストケースを作成した場合、全組合せ総数は$3 \times 2 \times 3 = 18個$となる。
これに対して、ペアワイズ法を用いてテストケースを作成した場合のテストケース例を、表\ref{tab:example_pairwise}に示す。
表\ref{tab:example_pairwise}から、テストケースの数を9個程度に抑えることができることが確認できる。


\section{ドメイン分析テスト}\label{cha:domain}
本研究における、ドメイン分析テストの定義と、ドメインテストが必要となる仕様の例を、以下で示す。

\subsection{ドメイン分析テストの定義}\label{sec:define}
本研究におけるドメイン分析テストとは、関係性がある複数の変数を同時にテストする方法である\cite{izon}\cite{istqb}。
ドメインとは、入力するデータの定義域である。
ドメイン分析とは、入力する変数と条件式を分析し、ドメインを抽出することである。
ドメイン分析テストでは、ドメインごとにonポイント、offポイント、inポイント、outポイントと呼ばれる入力値、および、それを元にしたテストケースを作成し、テストする。
境界値とは、同値分割した領域の端、あるいは端のどちらか側で最小の増加的距離にある入力値、または、出力値である\cite{istqb}。
本研究では、境界値の中でも、条件式を満たす境界値を利用する。これを、TB(True Boundary)と命名する。
TBの定義を、以下に示す。
ここで、本研究における、複数の変数を含む条件式とは、片方の辺にのみ複数の変数が含まれ、もう片方の辺は定数のみの条件式を指すこととする。
すなわち、両辺に変数を含む条件式を持つ仕様は、本研究の対象としない。
\begin{itemize}
  \item $condition$が$exp = int$のとき、$TB = int$とする。
  \item $condition$が$exp < int$のとき、$TB = int - 1$とする。
  \item $condition$が$exp > int$のとき、$TB = int + 1$とする。
  \item $condition$が$exp <= int$のとき、$TB = int$とする。
  \item $condition$が$exp >= int$のとき、$TB = int$とする。
\end{itemize}
なお、$condition$を条件式、$exp$を左辺、$int$を右辺とし、
$condition$は、$exp ~~~ operator\{=, <, >, <=, >=\} ~~~ int$の形式でなければならない。
また、$int$は、整数でなければならない。

それぞれのポイントの定義を、以下に示す。
\begin{itemize}
  \item onポイント：着目条件式(後述)のTBである。ドメインを決定づける条件式に付き1つ生成する。他のonポイントと重複してはならない。$targetExp$を着目条件式とすると、onポイントは、$targetExp = True$かつ$exp = TB$となる値でなければならない。
  \item offポイント：着目するonポイントに隣接し、TBでない値である。onポイントに付き複数(着目条件式に含まれる変数 $*$ 2)個存在する。$targetVar$を着目変数(後述)とすると、offポイントは、$targetVar + 1$となる値、または、$targetVar - 1$となる値でなければならない。
  \item inポイント：ドメインを決定づけるすべての条件式を満たす値である。ドメインに付き1つ生成する。onポイントやoffポイントと重複してはならない。$onPoints$をonポイントの集合とし、$offPoints$をoffポイントの集合、$inPoint$をinポイントとすると、inポイントは、 $(condition1 \land condition2 \land ... \land conditionN) = True$ かつ $inPoint \notin (onPoints \cup offPoints)$となる値でなければならない。
  \item outポイント：着目条件式のみを満たさない値である。ドメインを決定づける条件式に付き1つ生成する。offポイントと重複してはならない。$outPoint$をoutポイントとすると、outポイントは、$ (\lnot targetExp \land condition1 \land condition2 \land ... \land conditionN) = True$かつ$outPoint \notin offPoints$となる値でなければならない。
\end{itemize}
また、それぞれのポイントは、以下のパラメータを持つ。
\begin{itemize}
  \item 正常系判定値
        \begin{itemize}
          \item ``正常系''とは、ポイントの期待出力がドメインの期待出力と一致する状態のことを言う。
          \item ``非正常系''とは、ポイントの期待出力がドメインの期待出力と一致しない状態のことを言う。
          \item ``正常系判定値''とは、正常系であるかどうかを保持する値である。正常系か非正常系かの2つの状態を持つ。
        \end{itemize}
  \item 着目条件式\\
        onポイント、offポイント、outポイントのみが持つ。どの条件式に着目してポイントを生成したかの情報である。
  \item 着目変数\\
        offポイントのみが持つ。どの変数に着目して、onポイントに隣接するポイントを生成したかの情報である。
\end{itemize}

\subsection{ドメイン分析テストの例}
\begin{figure}[tp]
  \begin{lstlisting}[caption=ドメインテストが必要となる仕様(遊園地チケット割引機能),label=fig:vdm_park, language=]
class 遊園地チケット

functions

static public 割引判定 : int * int -> seq of char
  割引判定(夫の年齢, 妻の年齢) ==
    if(夫の年齢 + 妻の年齢 <= 50) then
      if(夫の年齢 >= 18) then
        if(妻の年齢 >= 16) then
          ``割引価格となる''
        else
          ``割引価格とならない(妻の年齢 $<$ 16)''
      else
        ``割引価格とならない(夫の年齢 $<$ 18)''
    else
      ``割引価格とならない(夫の年齢 + 妻の年齢 > 50)'';

end 遊園地チケット
\end{lstlisting}
\end{figure}

ドメイン分析テストが必要となる仕様の例として、遊園地チケット割引機能をテストすることを考える。遊園地チケット割引機能は、夫婦である夫と妻それぞれの年齢を入力とし、割引価格が適用されるかどうかを判定する関数であり、以下のルールを持つ。
\begin{enumerate}
  \renewcommand{\labelenumi}{\Alph{enumi})}
  \item\label{enu:yuenchi} 以下の条件をすべて満たすとき、遊園地チケットは割引価格となる。
        \begin{itemize}
          \item 夫の年齢と妻の年齢の合計が50歳以下である。
          \item 夫の年齢は18歳以上である。
          \item 妻の年齢は16歳以上である。
        \end{itemize}
  \item A) でない場合、遊園地チケットは割引価格とならない。
\end{enumerate}
この仕様をVDM++で記述した仕様を、コード\ref{fig:vdm_park}に示す。
7行目に、複数の変数を左辺に含む条件式があるため、既存のBWDMではテストケース生成ができない。
また、``割引価格となる''というドメインの各ポイントを生成した例を、図\ref{fig:domain_points}に示す。
ドメインを決定づける3つの条件式は、``夫の年齢 + 妻の年齢 $<=$ 50''、``夫の年齢 $>=$ 18''、``妻の年齢 $>=$ 16''である。
onポイントは、``On1''〜``On3''の3つであり、それぞれ、条件式の境界線上に存在する。
offポイントは、``Off11''〜``Off32''の8つである。``Off11''〜``Off14''は``夫の年齢 + 妻の年齢 $<=$ 50''という条件式に着目した``On1''に隣接するoffポイントであり、4つ存在する。これは、``夫の年齢''を正負の方向にそれぞれずらしたoffポイントが2つ存在し、同じように、``妻の年齢''を正負の方向にそれぞれずらしたoffポイントが2つ存在するためである。
しかし、``On2''のoffポイントは``Off21''、 ``Off22''の2つのみである。これは、``夫の年齢''をずらしたoffポイントが``妻の年齢 $>=$ 16''となり、TBとなるからである。
inポイントは、``In''の1つであり、``割引価格となる''ドメインのすべての条件式を満たす値を持つ。
outポイントは、``Out1''〜``Out3''の3つであり、それぞれの着目条件式のみを満たさない値を持つ。

\begin{figure}[tp]
  \centering
  \includegraphics[keepaspectratio, width=160mm]{figs/domain_points}
  \caption{遊園地チケット割引機能(コード\ref{fig:vdm_park})の割引になる条件にドメイン分析を適用した例}
  \label{fig:domain_points}
\end{figure}



% 既存
\chapter{既存の\tool{}}\label{cha:Exist}
本章では、既存のBWDM(Boundary Value/Vienna Develop Method)について説明する。

\section{機能}
既存のBWDM(Boundary Value/Vienna Develop Method)は、立山氏が開発した、VDM++仕様を対象としたテストケース生成ツールである。
関数定義に含まれる、if-then-else式の構造認識に基づいたテストを実施するためのテストケースを自動生成する\cite{tachiyama6}。


既存のBWDMには、以下の機能がある。

\begin{itemize}
  \item 記号実行によるテストケース生成
  \item 境界値分析によるテストケース生成
\end{itemize}

記号実行によって生成したテストケースは、すべての実行フローを網羅できることが期待できる。
境界値分析によって生成したテストケースは、境界値テストに使用することができる。
既存のBWDMを使用することにより、VDM++仕様を用いたソフトウェア開発効率を改善できる。

\begin{figure}[tp]
  \centering
  \includegraphics[keepaspectratio, width=160mm]{figs/exist_bwdm_structure.png}
  \caption{既存のBWDMの構造}
  \label{fig:existBwdmStructure}
\end{figure}

既存のBWDMの構造を、図\ref{fig:existBwdmStructure}に示す。

\section{入出力例}

\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption=VDM++仕様の例,label=fig:input_sample]
class SampleClass

functions

sampleFunction : int*nat*nat -> seq of char
  sampleFunction(a, b, c) == 
    if(a < 100) then
      if(b > 2018) then
        "aは100未満かつbは2018より大きい"
      else
        "aは100未満かつbは2018以下"
    elseif(c < 12) then
      "aは100以上かつcは12未満"
    else
      "aは100以上かつcは12以上";

end SampleClass

\end{lstlisting}
\end{figure}

\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption=既存のBWDMのテストケース出力例(コード\ref{fig:input_sample}を適用),label=fig:testcase_sample]

関数名 : sampleFunction
引数の型 : a:int b:nat c:nat 
戻り値の型 : seq of (char)
生成テストケース数 : 220件(境界値分析:216/記号実行:4)

各引数の境界値
a : 2147483648 2147483647 -2147483648 -2147483649 99 100 
b : 4294967295 4294967294 0 -1 2019 2018 
c : 4294967295 4294967294 0 -1 11 12 

記号実行情報
戻り値の数 : 4
制約 : b > 2018 and a < 100, 戻り値 : "aは100未満かつbは2018より大きい"
制約 : !( b > 2018 ) and a < 100, 戻り値 : "aは100未満かつbは2018以下"
制約 : c < 12 and !( a < 100 ) , 戻り値 : "aは100以上かつcは12未満"
制約 : !( c < 12 ) and !( a < 100 ) , 戻り値 : "aは100以上かつcは12以上"

境界値分析によるテストケース
No.1 : 2147483648 4294967295 4294967295 -> Undefined Action
No.2 : 2147483647 4294967295 4294967295 -> Undefined Action
No.3 : -2147483648 4294967295 4294967295 -> Undefined Action
No.4 : -2147483649 4294967295 4294967295 -> Undefined Action
No.5 : 99 4294967295 4294967295 -> Undefined Action

~~~中略~~~

No.212 : 2147483647 2018 12 -> "aは100以上かつcは12以上"
No.213 : -2147483648 2018 12 -> "aは100未満かつbは2018以下"
No.214 : -2147483649 2018 12 -> Undefined Action
No.215 : 99 2018 12 -> "aは100未満かつbは2018以下"
No.216 : 100 2018 12 -> "aは100以上かつcは12以上"

記号実行によるテストケース
No.1 : 99 2019 1 -> "aは100未満かつbは2018より大きい"
No.2 : 99 2018 1 -> "aは100未満かつbは2018以下"
No.3 : 100 b 11 -> "aは100以上かつcは12未満"
No.4 : 100 b 12 -> "aは100以上かつcは12以上"

\end{lstlisting}
\end{figure}

\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption=既存のBWDMのテストケースの出力フォーマット,label=fig:bwdm_format]

各引数の境界値
<引数1>: <入力値1> ... <入力値N>
・
・
・
<引数N>: <入力値1> ... <入力値N>

境界値分析によるテストケース（ペアワイズ法適用）
<ID> : <入力値1> ... <入力値N> -> <期待出力>

記号実行によるテストケース
<ID> : <入力値1> ... <入力値N> -> <期待出力>

\end{lstlisting}
\end{figure}

3つの引数(a, b, c)を入力とするVDM++仕様ファイルの例をコード\ref{fig:input_sample}に、
このファイルから生成したテストケースの例をコード\ref{fig:testcase_sample}に、それぞれ示す。
また、テストケースの出力フォーマットを、コード\ref{fig:bwdm_format}に示す。
コード\ref{fig:testcase_sample}において、``各引数の境界値''には、引数a、b、cそれぞれの境界値の集合を出力している。
そして、``境界値分析によるテストケース''には、各引数の境界値の総組合せのテストスイートを出力している。
また、``記号実行によるテストケース''には、関数のすべての実行フローを網羅できるテストスイートを出力している。

\section{問題点}\label{sec:bwdm_problem}
既存のBWDMには5つの問題点がある。問題点を、以下で説明する。

\subsection{組合せ爆発に関する問題点}\label{sec:problem_pairwise}
境界値分析によるテストケース生成において、生成するテストケース数は、因子が取り得るそれぞれの値の数(水準)を掛け合わせることにより決定する。
たとえば、因子が6で水準が(6, 6, 2, 4, 5, 7)の場合、既存のBWDMは、$6 \times 6 \times 2 \times 4 \times 5 \times 7＝10,080個$のテストケースを生成する。
したがって、組合せ爆発を起こす可能性があるという問題がある。

本研究では、組合せ爆発を起こす可能性があるという問題を解決するために、テストケース生成時にペアワイズ法を適用することで、BWDMを拡張する。

\subsection{複数変数を含む条件式に関する問題点}\label{sec:problem_double_var}

既存のBWDMには、左辺に複数の変数を含む条件式を持つ仕様のテストケースを生成できないという問題がある。
コード\ref{fig:vdm_park}に示したVDM++仕様には、7行目の条件式の左辺に複数の変数が含まれているため、この仕様を既存のBWDMに適用しても、テストケースを生成できない。

この理由を、既存のBWDMに コード\ref{fig:vdm_park}の仕様を入力した場合を例に、以下で説明する。

\begin{itemize}
  \item  コード\ref{fig:vdm_park}の6行目にて、入力する2つの変数は``夫の年齢''と``妻の年齢''と定義している。7行目のif条件式は``夫の年齢''と``妻の年齢''の2つの変数を利用しているが、既存のBWDMは``夫の年齢+妻の年齢''という1つの変数だと解釈する。``夫の年齢+妻の年齢''という引数は仕様に定義されていないため、既存のBWDMはエラーを出力し、動作を停止してしまう。
  \item  コード\ref{fig:vdm_park}の7行目の``夫の年齢+妻の年齢$<$=50''という条件式のTBを求めるには、「制約を満たす入力があるかどうか」という、充足可能性問題(Satisfiable Problem、SAT)\cite{sat}を解かなければならない。しかし、既存のBWDMは、充足可能性問題を解くことができない。
\end{itemize}

本研究では、左辺に複数の変数を含む条件式を持つ仕様のテストケース生成ができないという問題を解決するために、ドメイン分析テストのためのテストケース生成手法を提案し、既存のBWDMに適用することで、BWDMを拡張する。

\subsection{1つの関数しかテストケースを生成できない問題点}\label{sec:probrem_only_function}
既存の\tool{}には、1つの関数しかテストケースを生成できないという問題がある。
したがって、複数の関数を含む仕様のテストケースを生成した際に、最後に定義した関数のテストケースしか出力できない。
複数の関数を含むVDM++仕様を、コード\ref{fig:func_multiple}に示す。このVDM++仕様には「うるう年判定」関数と「成人判定」関数が定義されている。
コード\ref{fig:func_multiple}を既存のBWDMに適用した際の出力を、コード\ref{fig:func_multiple_result}に示す。

既存のBWDMでは、図\ref{fig:existBwdmStructure}の構文解析処理で定義ごとの抽象構文木を生成し、それらを抽象構文木解析処理に渡す。
抽象構文木解析処理では、受け取った抽象構文木の集合から、関数定義だけを抽出する。
受け取る抽象構文木の集合は、\ref{sec:vdmj}節で示した抽象クラス\ttt{TCDefinition}を継承したクラスの集合である。
既存のBWDMの抽象構文木解析処理を、以下に示す。

\newcommand{\TCExplicitFunctionDefinition}{\ttt{TCExplicitFunctionDefinition}}
\newcommand{\tcFunctionDefinition}{\ttt{tcFunctionDefinition}}
\newcommand{\astDefinition}{\ttt{astDefinition}}

\begin{enumerate}
  \item \TCExplicitFunctionDefinition{}型の変数\tcFunctionDefinition{}を宣言する。
  \item\label{enu:checkAstIsNull} 構文解析処理で生成した抽象構文木の集合が空であるか確認する。空でない場合、\ref{enu:ast_not_null}.へ進む。
        空である場合、変数\tcFunctionDefinition{}を構文木解析処理の出力とし、処理を終了する。
  \item\label{enu:ast_not_null} 抽象構文木の集合の先頭を取り出し、変数\astDefinition{}に格納する。
  \item\label{enu:ast_kind} \astDefinition{}\ttt{.kind()}を実行し、定義の種類を取得する。
  \item \ref{enu:ast_kind}.で取得した定義の種類(表\ref{tab:vdmj_definition_name}参照)が``explicit function''であるか確認する。
        ``explicit function''である場合、\ref{enu:ast_dainyu}.へ進む。
        ``explicit function''でない場合、\ref{enu:checkAstIsNull}.へ進む。
  \item\label{enu:ast_dainyu} 変数\astDefinition{}を\TCExplicitFunctionDefinition{}に型変換し、変数\tcFunctionDefinition{}に代入する。
        その後、\ref{enu:checkAstIsNull}.に進む。
\end{enumerate}

このように、抽象構文木解析処理では、受け取った定義の集合から、関数定義のみを抽出する。
抽出した関数定義ごとに、\TCExplicitFunctionDefinition{}型の変数に関数定義を代入するが、
この変数が1つしか用意されていないため、最終的に、VDM++仕様で最後に定義された関数のみが抽象構文木解析処理の出力となってしまう。
したがって、既存のBWDMは、1つの関数しかテストケース生成ができない。

本研究では、1つの関数しかテストケースを生成できないという問題を解決するために、既存の\tool{}の構文解析処理を修正し、複数の関数のテストケース生成に対応し、\tool{}を拡張する。

\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption=複数の関数を含むVDM++仕様,label=fig:func_multiple]
class 判定

functions

public うるう年判定 : int -> seq of char
  うるう年判定(年) ==
    if(年 mod 4 = 0) then
      if(年 mod 100 = 0) then
        if(年 mod 400 = 0) then
          "うるう年"
        else
          "平年"
      else
        "うるう年"
    else
      "平年";

public 成人判定 : nat -> seq of char
  成人判定(年齢) ==
    if(年齢 <= 20) then
      "未成年"
    else
      "成人";

end 判定
\end{lstlisting}
\end{figure}

\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption=複数の関数を含むVDM++仕様(コード\ref{fig:func_multiple})を既存のBWDMに適用した際の出力,label=fig:func_multiple_result]
関数名 : 成人判定
引数の型 : 年齢:nat 
戻り値の型 : seq of (char)
生成テストケース数 : 8件(境界値分析:6/記号実行:2)

各引数の境界値
年齢 : 4294967295 4294967294 0 -1 20 21 

記号実行情報
戻り値の数 : 2
制約 : 年齢 <= 20 , 戻り値 : "未成年"
制約 : !( 年齢 <= 20 ) , 戻り値 : "成人"

境界値分析によるテストケース
No.1 : 4294967295 -> Undefined Action
No.2 : 4294967294 -> "成人"
No.3 : 0 -> "未成年"
No.4 : -1 -> Undefined Action
No.5 : 20 -> "未成年"
No.6 : 21 -> "成人"

記号実行によるテストケース
No.1 : 1 -> "未成年"
No.2 : 21 -> "成人"
\end{lstlisting}
\end{figure}

\subsection{定数定義ブロック内の定義を含む関数のテストケースを生成できない問題点}\label{sec:probrem_value}
既存の\tool{}には、定数定義ブロック内の定義を含む関数を含む仕様のテストケースを生成できないという問題点がある。
定数定義ブロック内の定義を含む関数を含むVDM++仕様を、コード\ref{fig:value_definition}に示す。
このVDM++仕様には「偶数判定」関数が定義されている。
また、定数「even」を定義している。しかし、既存のBWDMは、定数定義ブロック内の定義を解析しない。
したがって、「偶数判定」関数内のevenを引数と判断するが、evenという引数は存在しないため、エラーを出力してしまう。

本研究では、定数定義ブロック内の定義を含む関数を含む仕様のテストケースを生成できないという問題を解決するために、既存の\tool{}の構文解析処理を拡張し、定数定義ブロック内の定義を含む関数のテストケース生成に対応することによって、\tool{}を拡張する。

\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption=定数定義ブロック内の定義を含む関数を含むVDM++仕様,label=fig:value_definition]
class 判定

values

public static even : int = 2;

functions

public 偶数判定 : int -> seq of char
  偶数判定(数) ==
    if(数 mod even = 0) then
      "偶数"
    else
      "奇数";

end 判定
\end{lstlisting}
\end{figure}

\subsection{操作のテストケースを生成できない問題点}\label{sec:probrem_operation}
既存の\tool{}には、操作のテストケースを生成できないという問題点がある。
操作を含むVDM++仕様を、コード\ref{fig:multiple_definition}に示す。
このVDM++仕様には、「西暦設定」操作と「うるう年判定」操作が定義されている。
また、インスタンス変数「current\_year」を定義している。
既存のBWDMは、インスタンス変数定義ブロック、および、操作定義ブロック内の定義を解析しない。
したがって、「西暦設定」操作と「うるう年判定」操作のテストケース生成を行わない。

本研究では、操作のテストケース生成ができないという問題を解決するために、既存の\tool{}の構文解析処理を拡張し、操作を含む仕様のテストケース生成に対応することによって、\tool{}を拡張する。
ただし、拡張するBWDMは、if-then-else式を含まない操作についてはテストケースを生成しない。
これは、BWDMがif-then-else式のみに基づいてテストケースを生成するためである。

\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption=操作を含むVDM++仕様,label=fig:multiple_definition]
class 判定

instance variables

private current_year : nat := 2000;

operations

public 西暦設定 : int ==> int
  西暦設定(年) == current_year := 年;

public うるう年判定 : () ==> seq of char
  うるう年判定() ==
    if(current_year mod 4 = 0) then
      if(current_year mod 100 = 0) then
        if(current_year mod 400 = 0) then
          return "うるう年"
        else
          return "平年"
      else
        return "うるう年"
    else
      return "平年";

end 判定
\end{lstlisting}
\end{figure}

% 拡張
\chapter{\tool{}の拡張}\label{cha:Extended}
\begin{table}[tp]
  \begin{center}
    \caption{本研究で行う拡張とそれぞれが対応する問題}
    \label{tab:problem_compare}
    \begin{tabular}{c|c}
      本研究で行う拡張           & 解決する問題 \\
      \hline
      \hline
      \begin{tabular}{c}
        ペアワイズ法の適用による \\テストケース数削減
      \end{tabular}
                                 &
      \begin{tabular}{c}
        組合せ爆発に関する問題点 \\(\ref{sec:problem_pairwise}節参照)
      \end{tabular}                \\ \hline
      \begin{tabular}{c}
        ドメイン分析テストの適用による \\複数変数を含む条件式を含む関数の\\テストケース生成
      \end{tabular} &
      \begin{tabular}{c}
        複数変数を含む条件式に関する問題点 \\(\ref{sec:problem_double_var}節参照)
      \end{tabular}                \\ \hline
                                 &
      \begin{tabular}{c}
        1つの関数しか \\テストケースを生成できない問題点  \\(\ref{sec:probrem_only_function}節参照)
      \end{tabular}                \\ \cline{2-2}
      複数の定義への対応         &
      \begin{tabular}{c}
        定数定義ブロック内の定義を含む関数を含む仕様の \\テストケースを生成できない問題点 \\(\ref{sec:probrem_value}節参照)
      \end{tabular}                \\ \cline{2-2}
                                 &
      \begin{tabular}{c}
        操作のテストケースを生成できない問題点 \\(\ref{sec:probrem_operation}節参照)
      \end{tabular}
    \end{tabular}
  \end{center}
\end{table}

\begin{figure}[tp]
  \centering
  \includegraphics[keepaspectratio, width=160mm]{figs/extended_bwdm_structure}
  \caption{本研究で拡張するBWDMの構造}
  \label{fig:extendedBwdmStructure}
\end{figure}

本章では、\tool{}の拡張について説明する。
既存のBWDMには5つの問題点がある(\ref{sec:bwdm_problem}節参照)。
これらの問題点を解決するために、本研究では、3つの拡張を行う。
また、拡張後のBWDMは、名称を\tool{}(\toolFullName{})に変更する\cite{bwdm}。

本研究で行う3つの拡張を、以下に示す。
\begin{itemize}
  \item ペアワイズ法の適用によるテストケース数削減
  \item ドメイン分析テストの適用による複数変数を含む条件式を含む関数のテストケース生成
  \item 複数の定義への対応
\end{itemize}

ここで、本研究で行う拡張とそれぞれが対応する問題を、表\ref{tab:problem_compare}に示す。
また、本研究で拡張するBWDMの構造を、図\ref{fig:extendedBwdmStructure}に示す。

以降、各拡張について説明する。

\section{ペアワイズ法の適用によるテストケース数削減}\label{sec:extendPairwise}
本研究では、pict4javaを開発する\cite{hirakoba1,hirakoba2,hirakoba3,hirakoba5,pict4java}。
pict4javaは、PICTとBWDMを接続するためのインタフェースである。
そして、既存のBWDMにpict4javaを組込むことで、BWDMを拡張する。
詳細を、以下に示す。

\subsection{pict4javaの概要}\label{sec:create_pict4java}
PICTは、CLI(Command Line Interface)ツールである。
API(PICTライブラリと呼称する)も提供しており、C++からのみ利用できる。
既存のBWDMはJavaで記述しており、PICTライブラリを呼び出すことができない。
そのため、BWDMの拡張の準備として、pict4javaを開発する。
pict4javaは、JNA(Java Native Access)\cite{jna}を利用し、Javaから呼び出すことのできるPICTライブラリである。

\begin{figure}[tp]
  \centering
  \includegraphics[keepaspectratio, width=160mm]{figs/pict4java_class}
  \caption{pict4javaのクラス図}
  \label{fig:pict4javaClass}
\end{figure}

\newcommand{\PictAddParameter}{\ttt{PictAddParameter}}
\newcommand{\PictGenerate}{\ttt{PictGenerate}}
\newcommand{\PictGetNextResultRow}{\ttt{PictGetNextResultRow}}
\newcommand{\createTask}{\ttt{createTask}}
\newcommand{\setRootModel}{\ttt{setRootModel}}
\newcommand{\generate}{\ttt{generate}}
\newcommand{\addFactor}{\ttt{addFactor}}


図\ref{fig:pict4javaClass}に、pict4javaのクラス図を示す。それぞれのクラスの説明を、以下に示す。
\begin{itemize}
  \item クラス\ttt{Pict}\\
        Microsoft社が開発したC++で記述されたPICTライブラリである。
  \item クラス\ttt{LibPict}\\
        JNA(Java Native Access)\cite{jna}を用いてJavaで記述したPICTライブラリのインタフェースである。
        メソッド名はすべて、PICTライブラリの持つ関数名と同じである。\\
        主に使用するPICTの関数を、以下に示す。
        \begin{description}
          \item[\PictAddParameter{}()] PICTへの因子と水準の登録
          \item[\PictGenerate{}()] 組合せデータの生成
          \item[\PictGetNextResultRow{}()] 生成データの取得
        \end{description}
  \item クラス\ttt{PictWrapper}\\
        PICTを操作するためのクラスである。Kotlin\cite{kotlin}で記述する。以下の機能を持つ。
        \begin{description}
          \item[\createTask{}()] \ttt{Task}の生成と初期化をする。
                \ttt{Task}は、PICTの組合せ生成処理の最小単位である。
                PICTライブラリにおける\ttt{PictCreateTask}に相当する。
          \item[\setRootModel{}()] \ttt{Task}にModelの登録をする。
                \ttt{Model}は因子の集合である。
                PICTライブラリにおける\ttt{PictSetRootModel}に相当する。
          \item[\generate{}()] ペアワイズ法を適用した組合せの生成をする。
                PICTライブラリにおける\PictGenerate{}に相当する。
        \end{description}
  \item クラス\ttt{Model}\\
        因子の集合を保持するためのクラスである。Kotlinで記述する。
        \begin{description}
          \item[コンストラクタ()] PICTライブラリにおける\ttt{Model}を生成する。\ttt{PictCreateModel}に相当する。
          \item[\addFactor{}()] 因子(\ttt{Factor})を\ttt{Model}に登録する。PICTライブラリにおける\PictAddParameter{}に相当する。
        \end{description}
  \item クラス\ttt{Factor}
        \begin{description}
          \item[\ttt{level}] 水準
          \item[\ttt{named\_level}] 因子の取り得る値の集合
          \item[\ttt{n}] 最低限組合せるペア数(デフォルトは2)
          \item[\ttt{weights}] 因子の取り得る値の重みの集合
          \item[\ttt{name}] 因子の名前
        \end{description}
        メンバ変数\ttt{n}の値を変えることによって、その因子については、n個の組合せを網羅する入力データを作成できる。
\end{itemize}

図\ref{fig:extendedBwdmStructure}の「A」の文字の箇所が、本節で拡張した処理である。
境界値分析部ではまず、テストケースの入力データとして、VDM++仕様内の引数ごとにおける、不等式、剰余式などに合わせた境界値、および、型の最小値、最大値の境界値を、それぞれ抽出する。
既存のBWDMでは、引数ごとに生成した境界値のすべての組合せを生成し、境界値テストの入力データとしていた。

拡張後のBWDMでは、すべての組合せを生成するのではなく、\ref{sec:create_pict4java}節で述べたpict4javaを用いてペアワイズ法を適用し、入力データ生成を行う。
具体的には、境界値分析で得た因子が取り得る値をpict4javaに入力する。

境界値分析後の境界値データを受けとったpict4javaの入力データ生成アルゴリズムを、以下に示す。
また、このアルゴリズムを用いたpict4javaの処理の流れを、図\ref{fig:pict4java}に示す。
図中の赤文字は、アルゴリズムの項目と対応している。

\begin{figure}[tp]
  \centering
  \includegraphics[keepaspectratio, width=160mm]{figs/pict4java}
  \caption{pict4javaの処理の流れ}
  \label{fig:pict4java}
\end{figure}

\begin{enumerate}
  \item 因子と、因子の取り得る値を元に、クラス\ttt{Factor}のインスタンスを因子の数だけ生成する。
  \item クラス\ttt{Model}の\addFactor{}メソッドを用いて、\PictAddParameter{}関数を呼び出し、PICTに因子と因子ごとの水準を登録する。
  \item\label{enu:pict4java0} クラス\ttt{PictWrapper}の\generate{}メソッドを用いて、ペアワイズ法を適用した組合せデータのリストを生成する。
        組合せデータは文字列型の配列のリストである。
        詳細の処理を、以下に示す。
        \begin{enumerate}
          \item\label{enu:pict4java1} \PictGenerate{}関数を用いて、PICTにペアワイズ法を適用した組合せデータを生成させる。
          \item\label{enu:pict4java2} \PictGetNextResultRow{}関数を用いて(a)で生成した組合せデータを1件取得する。
                取得したデータは、因子が取り得るパラメータ群のインデックスとなる。因子の数だけ(b)の処理を繰り返す。
          \item (b)で取得したデータのインデックスに該当するパラメータを用いて、組合せデータのリストを生成する。
        \end{enumerate}
  \item \ref{enu:pict4java0}.で生成したリストを、pict4javaの出力データとする。
\end{enumerate}

\section{ドメイン分析テストの適用による複数変数を含む条件式を含む関数のテストケース生成}\label{sec:extendDomain}

図\ref{fig:extendedBwdmStructure}の「B」の文字の箇所が、本節で拡張した処理である。
既存のBWDMでは、入力したVDM++仕様を構文解析し、その結果を、境界値分析部と記号実行部に渡し、テストケースにおける入力データを生成する。

拡張するBWDMには、境界値分析部、記号実行部に加えて、ドメイン分析部を追加する\cite{hirakoba4}。
ドメイン分析部では、\ref{sec:define}節で記述した、inポイント、outポイント、onポイント、offポイントを生成する。
また、複数の変数が条件式に含まれるVDM++仕様の解析に対応できるように、構文解析部を一部修正する。
さらに、ドメインテストに必要な、正常系判定値と着目条件式、着目変数の情報をテストケースに含めるために、テストケース生成部において、ドメインテストによるテストケースを出力する際、既存の出力に加えて、正常系判定値と着目条件式、着目変数の情報も出力するよう処理を追加する。

\subsection{構文解析部}
% BWDMの構文解析は、Nickらの開発したVDM構文解析ツールVDMJを用いて実現している\cite{vdmj}。
既存のBWDMは、各条件式の左辺に複数の変数を含む場合、エラーを出力してしまう(\ref{sec:bwdm_problem}節参照)。
左辺に複数の変数が条件式に含まれるVDM++仕様の構文解析を可能とするために、if条件式の左辺と右辺の式を構文解析し、条件式内の変数を抽出する。

\subsection{ドメイン分析部}\label{cha:DomainAnalyzer}
拡張するBWDMはドメイン分析テストにおける、onポイント、offポイント、inポイント、outポイントを生成するために、ドメイン分析部を持つ。
各ポイントは、テストケースの入力データであり、引数名と値のタプルの配列を保持している。
各ポイントの生成については、\ref{cha:create_point}節にて説明する。

\begin{figure*}[t]
  \begin{center}
    \includegraphics[keepaspectratio, width=160mm]{figs/DomainAnalyzer.png}
    \caption{ドメイン分析部のクラス図}
    \label{fig:class_DomainAnalyzer}
  \end{center}
\end{figure*}

作成するドメイン分析部のクラス図を、図\ref{fig:class_DomainAnalyzer}に示す。
各クラスの詳細を、以下に示す。

\newcommand{\forcusedConditionalExpression}{\ttt{forcusedConditionalExpression}}

\begin{itemize}
  \item \ttt{Factor}クラスは、引数の情報を持つクラスである。変数名(\ttt{name})と値(\ttt{value})を保持する。
  \item \ttt{Point}クラスは、テストケースの入力データの情報を持つクラスである。テストケース名(\ttt{name})、そのポイントが着目条件式(\forcusedConditionalExpression{})、そのポイントの着目変数(\ttt{forcusedVariable})、そして複数の\ttt{Factor}(\ttt{factors})を保持する。
  \item \ttt{DomainPoints}クラスは、ドメインの情報を持つクラスである。ドメインの期待出力(\ttt{name})、onポイントの集合(\ttt{onPoints})、offポイントの集合(\ttt{offPoints})、inポイント(\ttt{inPoints})、outポイントの集合(\ttt{outPoints})を保持する。
  \item \ttt{DomainAnalyzer}クラスは、ドメイン分析を行うクラスである。ドメインの集合(\ttt{domains})を保持している。
        また、onポイント、offポイント、inポイント、outポイントを生成する機能(\ttt{generateXXPoints}メソッド)、および、各ドメインの各ポイントを、期待出力生成部に入力できるデータ構造として抽出する機能(\ttt{getAllTestCaseByDomainAnalyzer}メソッド)を持つ。

\end{itemize}

\subsection{各ポイントの生成手法の提案と適用}\label{cha:create_point}
拡張するBWDMは、入力する仕様のドメインごとに、onポイント、offポイント、inポイント、outポイントを生成する。

各ポイントを満たす変数の値を求めるために、SMTソルバ(Satisfiable Modulo Theories)\cite{sat}を利用する。
充足可能性問題(SAT)を解くアルゴリズムを実装したソフトウェアをSATソルバと呼び、SATソルバを算術演算に対応させたソフトウェアをSMTソルバと呼ぶ。
幅広く知られているSMTソルバの1つに、Microsoft Researchが開発を進めているZ3\cite{z3}がある。
Z3は、C、C++、Java、Pythonなどのプログラミング言語から利用できるAPIを提供する。
拡張するBWDMは、このZ3を利用し、条件式を満たす入力値を生成する。

各ポイントの生成方法を、以下に示す。

\subsubsection{onポイント}
onポイントは、着目条件式のTBである。ドメインを決定づける条件式に付き1つ生成し、他のonポイントと重複してはならない。
ドメインに関わる条件式の数だけ以下の手順を繰り返し、各条件式に着目したonポイントを生成する。
\begin{enumerate}
  \item\label{enu:onpoint_2} もし、着目条件式の比較演算子が、``$>=$''、または、``$<=$''である場合、``=''に置き換える。``$>$''である場合、``=''で置き換え、右辺を``+1''する。``$<$''である場合、``=''で置き換え、左辺を``+1''する。
  \item\label{enu:onpoint_1} \ref{enu:onpoint_2}.で修正した条件式と、その他の条件式をZ3に入力し、解(引数と値のタプルの集合)を求める。解が求まらなかった場合、現在の着目条件式におけるonポイントが存在しないため、生成を行わずに次の着目条件式のonポイントの生成を行う。
  \item 配列\ttt{onPoints}(\ref{cha:DomainAnalyzer}節参照)を参照し、他のonポイントと値が重なるかどうかを判定する。
        \begin{enumerate}
          \item 重なっている場合、条件式に、''重なっている変数 $!=$ 重なった値``という条件式を加え、\ref{enu:onpoint_1}.に戻る。
          \item 重なっていない場合、解を元に、\ttt{Point}インスタンス(\ref{cha:DomainAnalyzer}節参照)を作り、メンバ\forcusedConditionalExpression{}には、着目条件式を格納する。
                作成したインスタンスを配列\ttt{onPoints}に格納する。
        \end{enumerate}
\end{enumerate}

\subsubsection{offポイント}
offポイントは、着目するonポイントに隣接し、TBでない値である。onポイントに付き複数(着目条件式に含まれる変数 $*$ 2)個存在する。
配列\ttt{onPoints}(\ref{cha:DomainAnalyzer}節参照)を参照し、onポイントの数だけ以下の手順を繰り返し、onポイントに着目したoffポイントを生成する。
\begin{enumerate}
  \item\label{enu:offpoint_2} 着目するonポイントのメンバ\forcusedConditionalExpression{}を参照し、着目するonポイントがどの条件式に着目していたかを保持する。
  \item \ref{enu:offpoint_2}.の条件式から、引数を抽出する。抽出した引数の数だけ以下を繰り返す。
        \begin{enumerate}
          \item 以下の処理を2回繰り返す。1回目は``N=$-$1''と定義し、2回目は``N=1''と定義する。
                \begin{enumerate}
                  \item\label{enu:offpoint_3} 着目するonポイントインスタンスをコピーする。
                  \item\label{enu:offpoint_1} i.でコピーした\ttt{Point}インスタンスのメンバ配列\ttt{factors}から、``\ttt{Factor.name} == 引数名''となる\ttt{Factor}インスタンスを検索する。
                  \item ii.で検索して見つかった\ttt{Factor}インスタンスのメンバ\ttt{value}を``+N''する。
                  \item \ttt{Point}インスタンスのメンバ\ttt{forcusedVariable}に引数名を格納する。
                  \item \ttt{Point}インスタンスを配列\ttt{offPoints}(\ref{cha:DomainAnalyzer}節参照)に格納する。
                \end{enumerate}
        \end{enumerate}
\end{enumerate}

\subsubsection{inポイント}
in ポイントは、ドメインを決定づけるすべての条件式を満たす値である。ドメインに付き1つ生成し、他のonポイント、offポイントと重複してはならない。
以下の手順を行い、inポイントを生成する。
\begin{enumerate}
  \item\label{enu:inpoint_2} もし、条件式の比較演算子が、``$>=$''である場合、``$>$''で置き換える。``$<=$''である場合、``$<$''で置き換える。これを、すべての条件式に対して行う。
  \item\label{enu:inpoint_1} \ref{enu:inpoint_2}.で修正した条件式をZ3に入力し、解(引数と値のタプルの集合)を求める。解が求まらなかった場合、inポイントが存在しないため、生成を行わない。
  \item 配列\ttt{onPoints}と配列\ttt{offPoints}(\ref{cha:DomainAnalyzer}節参照)を参照し、他のonポイント、offポイントと値が重なるかどうかを判定する。
        \begin{enumerate}
          \item 重なっている場合、条件式に、''重なっている変数 $!=$ 重なった値``という条件式を加え、\ref{enu:inpoint_1}.に戻る。
          \item 重なっていない場合、解を元に、\ttt{Point}インスタンス(\ref{cha:DomainAnalyzer}節参照)を作り、配列\ttt{inPoints}に格納する。
        \end{enumerate}
\end{enumerate}

\subsubsection{outポイント}
outポイントは、着目条件式のみを満たさない値である。ドメインを決定づける条件式に付き1つ生成し、他のoffポイントと重複してはならない、
ドメインに関わる条件式の数だけ以下の手順を繰り返し、各条件式に着目したoutポイントを生成する。
\begin{enumerate}
  \item\label{enu:outpoint_2} 着目条件式を``$!$(着目条件式)''に置き換え、否定する。
  \item\label{enu:outpoint_1} \ref{enu:outpoint_2}.で否定した条件式と、その他の条件式をZ3に入力し、解(引数と値のタプルの集合)を求める。
        解が求まらなかった場合、現在の着目条件式におけるoutポイントが存在しないため、生成を行わずに次の着目条件式のoutポイントの生成を行う。
  \item 配列\ttt{onPoints}と配列\ttt{offPoints}(\ref{cha:DomainAnalyzer}節参照)を参照し、他のonポイント、offポイントと値が重なるかどうかを判定する。
        \begin{enumerate}
          \item 重なっている場合、条件式に、''重なっている変数 $!=$ 重なった値``という条件式を加え、\ref{enu:outpoint_1}.に戻る。
          \item 重なっていない場合、解を元に、\ttt{Point}インスタンス(\ref{cha:DomainAnalyzer}節参照)を作り、メンバ\forcusedConditionalExpression{}には、着目条件式を格納する。作成したインスタンスを配列\ttt{outPoints}に格納する。
        \end{enumerate}
\end{enumerate}

\subsection{テストケースの生成}
\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption=ドメイン分析テストのためのテストケースの出力フォーマット,label=fig:dmin_output_format]

ドメインテストによるテストケース
- <ドメインの期待出力>
-- Onポイント
<ID> : <入力値1> ... <入力値N>, <正常系かどうか>, <着目する条件式> -> <期待出力>

-- Offポイント
<ID> : <入力値1> ... <入力値N>, <正常系かどうか>, <着目する条件式>, <着目する条件式> -> <期待出力>

-- Inポイント
<ID> : <入力値1> ... <入力値N>, <正常系かどうか> -> <期待出力>

-- Outポイント
<ID> : <入力値1> ... <入力値N>, <正常系かどうか>, <着目する条件式> -> <期待出力>

- <ドメイン名2>

・
・
・

- <ドメイン名N>

\end{lstlisting}
\end{figure}

既存のBWDMは、期待出力生成部において、入力データを元に期待出力を生成する機能を持つ。
\ttt{DomainAnalyzer}クラス(\ref{cha:DomainAnalyzer}節参照)の\ttt{getAllTestCaseByDomainAnalyzer}メソッドを呼び出すことにより、\ref{cha:create_point}節で生成した各ドメインの各ポイントを、期待出力生成部に入力できるデータ構造として抽出できる。
そのため、既存のBWDMの期待出力生成部をそのまま用いて、期待出力生成とテストケース生成は可能である。
拡張するBWDMでは、各ドメインの各ポイントのテストケースを出力する。

しかし、既存のBWDMのテストケース生成部には、ドメインテストに必要な、正常系判定値と着目条件式、着目変数の情報を出力テストケースに加える処理が存在しない。
これに対応するため、テストケース生成部において、ドメインテストによるテストケースを出力する際、正常系判定値と着目条件式、着目変数の情報についても出力するよう処理を追加する。
着目条件式の出力には、\ttt{Point}インスタンスのメンバ\forcusedConditionalExpression{}を参照する。
offポイントの場合、着目変数の出力を行う。出力には、\ttt{Point}インスタンスのメンバ\ttt{forcusedVariable}を参照する。
正常系判定値は、出力するテストケースの期待出力と、ドメインの期待出力(\ttt{DomainPoints.name})を比較して判断する。
等しければ、``正常系''と出力する。等しくなければ``非正常系''と出力する。

最後に、出力テストケースのフォーマット(コード\ref{fig:dmin_output_format}参照)の$<$と$>$で囲まれている部分を、それぞれの情報で置き換える。
置き換えたファイルをテストスイートとして出力する。

\section{複数の定義への対応}\label{sec:extendMultiple}
図\ref{fig:extendedBwdmStructure}の「C」の文字の箇所が、本節で拡張した処理である。
既存のBWDMでは、入力したVDM++仕様を構文解析部に入力し、字句解析、構文解析、抽象構文木解析を順に行い、最後に定義された定義の抽象構文木を抽出する。

拡張するBWDMには、\ref{sec:probrem_value}節と\ref{sec:probrem_operation}節で述べた、関数定義以外の定義に対応していないという問題を解決するために、抽象クラス\ttt{Definition}、クラス\ttt{FunctionDefinition}、クラス\ttt{OperationDefinition}を新規に作成し、追加する。
また、\ref{sec:probrem_only_function}節で述べた、1つの関数しかテストケース生成できないという問題を解決するため、構文解析部の抽象構文木解析処理を一部修正する。

\subsection{定義クラス群の作成}\label{sec:create_definition}
\begin{figure}[tp]
  \centering
  \includegraphics[keepaspectratio, width=160mm]{figs/Definition_class_diagram}
  \caption{定義クラス群とそれに関連するクラスのクラス図}
  \label{fig:definition_class}
\end{figure}

関数定義以外の定義に対応するために、抽象クラス\ttt{Definition}、クラス\ttt{FunctionDefinition}、クラス\ttt{OperationDefinition}を作成する。
これらの、定義クラス群の関係を、図\ref{fig:definition_class}に示す。
図中にある、VDMJパッケージのクラスはVDMJであらかじめ用意されているクラス(\ref{sec:vdmj}節参照)である。

それ以外のクラスの説明を、以下に示す。

\begin{itemize}
  \item 抽象クラス\ttt{Definition}\\
        テストケース生成を行う定義を表す抽象クラスである。\ttt{TCDefinition}型のオブジェクトを元に、if-then-else式から木構造を生成する\cite{tachiyama6}。以下のフィールドとメソッドを持つ。
        \begin{description}
          \item[\ttt{name}] 定義の名前
          \item[\ttt{constantValues}] 定数定義の集合
          \item[\ttt{returnType}] 戻り値の型
          \item[\ttt{argumentTypes}] 引数の型の集合
          \item[\ttt{parameters}] 仮引数名の集合
          \item[\ttt{setIfElseSyntaxTree()}] if-then-else式から木構造を生成する抽象メソッド
          \item[\ttt{createIfCondition()}] if-then-else式を構文解析する
        \end{description}

  \item クラス\ttt{FunctionDefinition}\\
        テストケース生成を行う関数を表すクラスである。\TCExplicitFunctionDefinition{}型のオブジェクトを元に、if-then-else式から木構造を生成する。
        以下のフィールドとメソッドを持つ。
        \begin{description}
          \item[\ttt{setIfElseSyntaxTree()}] if-then-else式から木構造を生成する。インスタンス生成時にコンストラクタから呼び出される
        \end{description}

  \item クラス\ttt{OperationDefinition}\\
        テストケース生成を行う操作を表すクラスである。\ttt{TCExplicitOperationDefinition}型のオブジェクトを元に、if-then-else式から木構造を生成する。
        以下のフィールドとメソッドを持つ。
        \begin{description}
          \item[\ttt{\ttt{instanceVariables}}] インスタンス変数定義の集合
          \item[\ttt{setUsesInstanceVariables()}] if-then-else式で使用されるインスタンス変数を\ttt{argumentTypes}と\ttt{parameters}に追加する
          \item[\ttt{setIfElseSyntaxTree()}] if-then-else式から木構造を生成する。インスタンス生成時にコンストラクタが呼び出す
        \end{description}

  \item クラス\ttt{InformationExtractor}\\
        抽象構文木解析処理を行うクラスである。
        構文解析処理から受け取った、定義を表す抽象構文木の集合から、定義クラスの集合を生成する。
        \begin{description}
          \item[\ttt{\ttt{constantValues}}] 定数定義の集合
          \item[\ttt{\ttt{instanceVariables}}] インスタンス変数定義の集合
        \end{description}

\end{itemize}

\subsection{抽象構文木解析処理の修正}

\begin{comment}
\begin{figure}[tp]
  \centering
  \includegraphics[keepaspectratio, width=160mm]{figs/ExistAstAnalysis}
  \caption{既存のBWDMの抽象構文木解析処理}
  \label{fig:ExistAstAnalysis}
\end{figure}
\end{comment}

既存のBWDMでは、図\ref{fig:extendedBwdmStructure}に示した構文解析処理で定義ごとの抽象構文木を生成し、それらを抽象構文木解析処理に渡す。
抽象構文木解析処理では、受け取った抽象構文木の集合から、関数定義であるものだけを抽出する。
受け取る抽象構文木の集合は、\ref{sec:create_definition}節で示した抽象クラス\ttt{TCDefinition}を継承したクラスの集合である。

拡張するBWDMでは、抽象構文木解析処理にて、受け取った抽象構文木を、\ref{sec:create_definition}節で作成した定義クラス群に変換し、連想配列に格納する。
拡張するBWDMの抽象構文木解析処理を以下に示す。以下の処理は\ttt{InformationExtractor}インスタンスにて行う。

\begin{enumerate}
  \item \ttt{FunctionDefinition}型の連想配列\ttt{explicitFunctions}をインスタンス化する。
  \item \ttt{OperationDefinition}型の連想配列\ttt{explicitOperations}をインスタンス化する。
  \item \ttt{TCValueDefinition}型の連想配列\ttt{constantValues}をインスタンス化する。
  \item \ttt{TCInstanceVariableDefinition}型の連想配列\ttt{instanceVariables}をインスタンス化する。
  \item\label{enu:checkAstIsNull3} 構文解析処理で生成した抽象構文木の集合が空であるか確認する。空でない場合、\ref{enu:ast_not_null3}.へ進む。
        空である場合、連想配列\ttt{explicitFunctions}と連想配列\ttt{explicitOperations}を構文木解析処理の出力とし、処理を終了する。
  \item\label{enu:ast_not_null3} 抽象構文木の集合の先頭を取り出し、変数\astDefinition{}に格納する。
  \item\label{enu:ast_kind3} \astDefinition{}.kind()を実行し、抽象構文木の種類を取得する。
  \item \ref{enu:ast_kind3}で取得した抽象構文木の種類を確認し、種類に応じて以下のいずれかを実行する。
        \begin{enumerate}
          \item ``explicit function''である場合、関数定義なので、以下を実行する。
                \begin{enumerate}
                  \item 変数\astDefinition{}を\TCExplicitFunctionDefinition{}に型変換し、クラス\ttt{FunctionDefinition}に渡し、インスタンス化する。
                  \item インスタンス化したクラス\ttt{FunctionDefinition}を、連想配列\ttt{explicitFunctions}に、キーを定義名(\astDefinition{}.name)として追加する。
                \end{enumerate}
          \item ``explicit operation''である場合、操作定義なので、以下を実行する。
                \begin{enumerate}
                  \item 変数\astDefinition{}を\ttt{TCExplicitOperationDefinition}に型変換し、クラス\ttt{OperationDefinition}に渡し、インスタンス化する。
                  \item インスタンス化したクラス\ttt{OperationDefinition}を、連想配列\ttt{explicitOperations}に、キーを定義名(\astDefinition{}\ttt{.name})として追加する。
                \end{enumerate}
          \item ``value''である場合、定数定義なので、\astDefinition{}を\ttt{TCValueDefinition}に型変換し、\ttt{tcValueDefinition}に追加する。
          \item ``instance variable''である場合、インスタンス変数定義なので、\astDefinition{}を\ttt{TCInstanceVariableDefinition}に型変換し、\ttt{tcInstanceVariableDefinition}に追加する。
          \item (a)、(b)、(c)、(d)のいずれでもない場合、\ref{enu:checkAstIsNull3}.へ進む。
        \end{enumerate}
\end{enumerate}

%拡張したBWDMの抽象構文木解析処理を図\ref{fig:ExtendedAstAnalysis}に示す。
\begin{comment}
\begin{figure}[tp]
  \centering
  \includegraphics[keepaspectratio, width=160mm]{figs/ExtendedAstAnalysis}
  \caption{拡張したBWDMの抽象構文木解析処理}
  \label{fig:ExtendedAstAnalysis}
\end{figure}
\end{comment}

\subsection{境界値分析部と記号実行部とドメイン分析部で定義クラス群を入力とするように修正}
既存のBWDMでは、境界値分析部、記号実行部、ドメイン分析部に入力するオブジェクトの型が\TCExplicitFunctionDefinition{}型のみであった。
したがって、拡張するBWDMでは、\ref{sec:create_definition}節で作成した定義クラス群を、境界値分析部、記号実行部、ドメイン分析部に入力できるように、それぞれの部を修正する。

% 適用例
\chapter{適用例}\label{cha:Indication}
本章では、本研究で拡張したBWDMが正しく動作することを、適用例を用いて確認する。


\section{因子と水準の組合せ数が大きい仕様}

\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption={因子が3で水準が(6, 6, 6)の関数を持つVDM++仕様},label=fig:pict4javaSampleVdm]
class SampleClass
functions

sampleFunction : int*nat*nat -> seq of char
sampleFunction(a, b, c)==
  if(a < 100) then
    if(b > 2018) then
      "aは100未満かつbは2018より大きい"
    else
      "aは100未満かつbは2018以下"
  elseif(c < 12) then
    "aは100以上かつcは12未満"
  else
    "aは100以上かつcは12以上";

end SampleClass
\end{lstlisting}
\end{figure}

\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption={拡張したBWDMに因子が3で水準が(6, 6, 6)の関数を持つ仕様(コード\ref{fig:pict4javaSampleVdm})を適用した際の出力},label=fig:pict4javaTekiyourei]

関数名 : sampleFunction
引数の型 : a:int b:nat c:nat 
戻り値の型 : seq of (char)
生成テストケース数 : 44件(境界値分析:40/記号実行:4)

各引数の境界値
a : 2147483648 2147483647 -2147483648 -2147483649 99 100 
b : 4294967295 4294967294 0 -1 2019 2018 
c : 4294967295 4294967294 0 -1 11 12 

記号実行情報
戻り値の数 : 4
制約 : b > 2018 and a < 100, 戻り値 : "aは100未満かつbは2018より大きい"
制約 : !( b > 2018 ) and a < 100, 戻り値 : "aは100未満かつbは2018以下"
制約 : c < 12 and !( a < 100 ) , 戻り値 : "aは100以上かつcは12未満"
制約 : !( c < 12 ) and !( a < 100 ) , 戻り値 : "aは100以上かつcは12以上"

境界値分析によるテストケース（ペアワイズ法適用）
No.1 : 100 4294967295 -1 -> Undefined Action
No.2 : 2147483648 2019 -1 -> Undefined Action
No.3 : 100 2019 11 -> "aは100以上かつcは12未満"
No.4 : 2147483648 2018 4294967294 -> Undefined Action
No.5 : 2147483647 -1 4294967294 -> Undefined Action
No.6 : -2147483649 0 0 -> Undefined Action
No.7 : 2147483648 -1 4294967295 -> Undefined Action
No.8 : 100 -1 12 -> Undefined Action
No.9 : -2147483649 2019 12 -> Undefined Action
No.10 : 99 -1 0 -> Undefined Action
No.11 : 99 4294967295 11 -> Undefined Action
No.12 : 99 2019 4294967294 -> "aは100未満かつbは2018より大きい"
No.13 : -2147483648 2018 -1 -> Undefined Action
No.14 : 100 2018 0 -> "aは100以上かつcは12未満"
No.15 : 99 4294967294 -1 -> Undefined Action
No.16 : -2147483649 2018 4294967295 -> Undefined Action
No.17 : 2147483647 4294967295 4294967295 -> Undefined Action
No.18 : 100 0 4294967295 -> Undefined Action
No.19 : 2147483647 0 12 -> "aは100以上かつcは12以上"
No.20 : 99 2018 12 -> "aは100未満かつbは2018以下"
No.21 : -2147483648 4294967294 4294967295 -> Undefined Action
No.22 : 2147483647 4294967294 0 -> "aは100以上かつcは12未満"
No.23 : 99 0 4294967295 -> Undefined Action
No.24 : -2147483649 4294967294 4294967294 -> Undefined Action
No.25 : 2147483647 2019 4294967295 -> Undefined Action
No.26 : -2147483648 0 11 -> "aは100未満かつbは2018以下"
No.27 : 2147483648 4294967294 11 -> Undefined Action
No.28 : 2147483647 -1 -1 -> Undefined Action
No.29 : -2147483649 -1 11 -> Undefined Action
No.30 : 100 4294967294 12 -> "aは100以上かつcは12以上"
No.31 : 2147483648 4294967295 0 -> Undefined Action
No.32 : 100 4294967295 4294967294 -> Undefined Action
No.33 : 2147483647 2018 11 -> "aは100以上かつcは12未満"
No.34 : 2147483648 0 4294967294 -> Undefined Action
No.35 : -2147483648 2019 0 -> "aは100未満かつbは2018より大きい"
No.36 : 2147483648 4294967295 12 -> Undefined Action
No.37 : -2147483648 4294967295 4294967294 -> Undefined Action
No.38 : -2147483648 -1 12 -> Undefined Action
No.39 : -2147483649 0 -1 -> Undefined Action
No.40 : -2147483649 4294967295 0 -> Undefined Action
\end{lstlisting}
\end{figure}

\ref{sec:extendPairwise}節で拡張したBWDMが正しく動作することを検証するため、拡張したBWDMに因子と水準の組合せ数が大きいVDM++仕様を適用した。
適用例として用いる、因子が3で水準が(6, 6, 6)の関数のVDM++仕様を、コード\ref{fig:pict4javaSampleVdm}に示す。
適用結果を、コード\ref{fig:pict4javaTekiyourei}に示す。

この例の場合、既存のBWDMでは$6 \times 6 \times 6 = 216個$のテストケースを生成する。
これに対して、拡張後のBWDMでは、コード\ref{fig:pict4javaTekiyourei}より、テストケースの生成を40個に抑えており、かつ、この40個のテストケースは、2個の因子のペアの組合せをすべて網羅できていることが確認できる。
すなわち、拡張したBWDMが、VDM++仕様から、ペアワイズ法を適用した境界値テストケースを正しく出力できていることが確認できた。


\section{複数変数を含む条件式を用いた仕様}
\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption={拡張したBWDMに遊園地チケット割引機能(コード\ref{fig:vdm_park})を適用した際の出力の一部},label=fig:park_testcase]
ドメインテストによるテストケース
- "割引価格となる"
-- Onポイント
No.1 : 20 16, 正常系, 妻の年齢>=16 -> "割引価格となる"
No.2 : 18 18, 正常系, 夫の年齢>=18 -> "割引価格となる"
No.3 : 32 18, 正常系, 夫の年齢+妻の年齢<=50 -> "割引価格となる"

-- Offポイント
No.1 : 20 17, 正常系, 妻の年齢>=16, 妻の年齢 -> "割引価格となる"
No.2 : 20 15, 非正常系, 妻の年齢>=16, 妻の年齢 -> "割引価格とならない(妻の年齢 < 16)"
No.3 : 32 19, 非正常系, 夫の年齢+妻の年齢<=50, 妻の年齢 -> "割引価格とならない(夫の年齢 + 妻の年齢 > 50)"
No.4 : 32 17, 正常系, 夫の年齢+妻の年齢<=50, 妻の年齢 -> "割引価格となる"
No.5 : 33 18, 非正常系, 夫の年齢+妻の年齢<=50, 夫の年齢 -> "割引価格とならない(夫の年齢 + 妻の年齢 > 50)"
No.6 : 31 18, 正常系, 夫の年齢+妻の年齢<=50, 夫の年齢 -> "割引価格となる"
No.7 : 19 18, 正常系, 夫の年齢>=18 -> "割引価格となる"
No.8 : 17 18, 非正常系, 夫の年齢>=18 -> "割引価格とならない(夫の年齢 < 18)"

-- Inポイント
No.1 : 20 18, 正常系 -> "割引価格となる"

-- Outポイント
No.1 : 20 0, 非正常系, 妻の年齢>=16 -> "割引価格とならない(妻の年齢 < 16)"
No.2 : 20 33, 非正常系, 夫の年齢+妻の年齢<=50 -> "割引価格とならない(夫の年齢 + 妻の年齢 > 50)"
No.3 : 0 18, 非正常系, 夫の年齢>=18 -> "割引価格とならない(夫の年齢 < 18)"

- "割引価格とならない（妻の年齢<16）"
-- Onポイント
No.1 : 20 15, 正常系, 妻の年齢>=16 -> "割引価格とならない（妻の年齢<16）"
No.2 : 18 10, 正常系, 夫の年齢>=18 -> "割引価格とならない（妻の年齢<16）"
No.3 : 40 10, 正常系, 夫の年齢 + 妻の年齢 <= 50 -> "割引価格とならない（妻の年齢<16）"

-- Offポイント
=======省略=======
\end{lstlisting}
\end{figure}

拡張したBWDMに、遊園地チケット割引機能(コード\ref{fig:vdm_park}参照)を入力として適用した結果の一部を、コード\ref{fig:park_testcase}に示す。
なお、コード\ref{fig:park_testcase}では、``割引価格となる''期待出力以外の3つの期待出力を持つドメイン(``割引価格とならない(妻の年齢 $<$ 16)''、``割引価格とならない(夫の年齢 $<$ 18)''、``割引価格とならない(夫の年齢 + 妻の年齢 $>$ 50)'')のテストケースは省略してある。

``割引価格となる''ドメインの3つのonポイントは、ドメインを決定づける3つの条件式(``夫の年齢 + 妻の年齢 $<=$ 50''、``夫の年齢 $>=$ 18''、``妻の年齢 $>=$ 16'')にそれぞれ着目し、着目条件式のTBが入力となっており、かつ、期待出力と正常系判定値(ポイントの期待出力とドメインの期待出力が一致するかどうか)が適切であることが確認できる。
offポイントは、各onポイントに隣接しており、TBではない値が入力となっており、かつ、着目変数、期待出力、正常系判定値が適切であることが確認できる。
inポイントは、期待出力とドメインの期待出力が一致しており、各条件式のTBでない値が入力となっており、かつ、正常系であることが確認できる。
outポイントは、関係する3つの条件式に着目し、着目条件式のみを否定するTBでない値が入力となっており、かつ、期待出力と正常系判定値が適切であることが確認できる。

また、コード\ref{fig:park_testcase}では省略している、``割引価格となる''期待出力以外の期待出力を持つドメイン(``割引価格とならない(妻の年齢 $<$ 16)''、``割引価格とならない(夫の年齢 $<$ 18)''、``割引価格とならない(夫の年齢 + 妻の年齢 $>$ 50)'')に対しても、テストケースが適切に生成できていることを確認した。

したがって、拡張したBWDMは、既存のBWDMの問題点である、条件式内に複数の変数があるVDM++仕様を解析できること、かつ、ドメインテストによるテストケース生成が適切にできることを確認できた。


\section{複数の関数を含む仕様}\label{sec:tekiyou_multi_func}
拡張したBWDMに、複数の関数を含む仕様(コード\ref{fig:func_multiple}参照)を入力として適用した結果を、コード\ref{fig:extended_func_multiple_result}に示す。
コード\ref{fig:extended_func_multiple_result}では、「成人判定」関数(37行目以降)だけでなく、「うるう年判定」関数(1-35行目)についてもテストケース生成が適切にできていることが確認できる。

したがって、拡張したBWDMは、既存のBWDMの問題点である、1つの関数しかテストケース生成できないという問題点を解決し、複数の関数のテストケース生成ができることを確認できた。

\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption=拡張したBWDMに複数の関数を含む仕様(コード\ref{fig:func_multiple})を適用した際の出力,label=fig:extended_func_multiple_result]
関数名 : うるう年判定
引数の型 : 年:int 
戻り値の型 : seq of (char)
生成テストケース数 : 17件(境界値分析:13/記号実行:4)

各引数の境界値
年 : 2147483648 2147483647 -2147483648 -2147483649 3 4 5 99 100 101 399 400 401 

記号実行情報
戻り値の数 : 4
制約 : 年 mod 400 = 0 and 年 mod 100 = 0and 年 mod 4 = 0, 戻り値 : "うるう年"
制約 : !( 年 mod 400 = 0 ) and 年 mod 100 = 0and 年 mod 4 = 0, 戻り値 : "平年"
制約 : !( 年 mod 100 = 0 ) and 年 mod 4 = 0, 戻り値 : "うるう年"
制約 : !( 年 mod 4 = 0 ) , 戻り値 : "平年"

境界値分析によるテストケース
No.1 : 2147483648 -> Undefined Action
No.2 : 2147483647 -> "平年"
No.3 : -2147483648 -> "うるう年"
No.4 : -2147483649 -> Undefined Action
No.5 : 3 -> "平年"
No.6 : 4 -> "うるう年"
No.7 : 5 -> "平年"
No.8 : 99 -> "平年"
No.9 : 100 -> "平年"
No.10 : 101 -> "平年"
No.11 : 399 -> "平年"
No.12 : 400 -> "うるう年"
No.13 : 401 -> "平年"

記号実行によるテストケース
No.1 : 400 -> "うるう年"
No.2 : 500 -> "平年"
No.3 : 104 -> "うるう年"
No.4 : 1 -> "平年"

関数名 : 成人判定
引数の型 : 年齢:nat 
戻り値の型 : seq of (char)
生成テストケース数 : 8件(境界値分析:6/記号実行:2)

各引数の境界値
年齢 : 4294967295 4294967294 0 -1 20 21 

記号実行情報
戻り値の数 : 2
制約 : 年齢 <= 20 , 戻り値 : "未成年"
制約 : !( 年齢 <= 20 ) , 戻り値 : "成人"

境界値分析によるテストケース
No.1 : 4294967295 -> Undefined Action
No.2 : 4294967294 -> "成人"
No.3 : 0 -> "未成年"
No.4 : -1 -> Undefined Action
No.5 : 20 -> "未成年"
No.6 : 21 -> "成人"

記号実行によるテストケース
No.1 : 1 -> "未成年"
No.2 : 21 -> "成人"

\end{lstlisting}
\end{figure}

\section{定数定義ブロック内の定義を含む関数を含む仕様}\label{sec:tekiyou_value}
拡張したBWDMに、定数定義ブロック内の定義を含む関数を含む仕様(コード\ref{fig:value_definition})を入力として適用した結果を、コード\ref{fig:extended_value_definition_result}に示す。
コード\ref{fig:extended_value_definition_result}では、12行目にて「$数 mod ~~ 2 = 0$」となっており、evenを2に正しく変換できていることが確認できる。
また、13行目も同様に確認できる。
また、入力と出力の組合せが正しいことから、テストケース生成が適切にできていることが確認できる。

したがって、拡張したBWDMは、既存のBWDMの問題点である、定数定義ブロック内の定義を含む関数を含む仕様のテストケース生成ができないという問題点を解決し、定数定義ブロック内の定義を含む関数を含む仕様のテストケース生成ができることを確認できた。

\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption=拡張したBWDMに定数定義ブロック内の定義を含む関数を含む仕様(コード\ref{fig:value_definition})を適用した際の出力,label=fig:extended_value_definition_result]

関数名 : 偶数判定
引数の型 : 数:int 
戻り値の型 : seq of (char)
生成テストケース数 : 9件(境界値分析:7/記号実行:2)

各引数の境界値
数 : 2147483648 2147483647 -2147483648 -2147483649 1 2 3 

記号実行情報
戻り値の数 : 2
制約 : 数 mod 2 = 0 , 戻り値 : "偶数"
制約 : !( 数 mod 2 = 0 ) , 戻り値 : "奇数"

境界値分析によるテストケース
No.1 : 2147483648 -> Undefined Action
No.2 : 2147483647 -> "奇数"
No.3 : -2147483648 -> "偶数"
No.4 : -2147483649 -> Undefined Action
No.5 : 1 -> "奇数"
No.6 : 2 -> "偶数"
No.7 : 3 -> "奇数"

記号実行によるテストケース
No.1 : 2 -> "偶数"
No.2 : 1 -> "奇数"

\end{lstlisting}
\end{figure}

\section{操作定義を含む仕様}\label{sec:tekiyou_operation}
拡張したBWDMに、操作定義を含む仕様(コード\ref{fig:multiple_definition}参照)を入力として適用した結果を、コード\ref{fig:extended_multiple_definition}に示す。
コード\ref{fig:extended_multiple_definition}では、インスタンス変数「current\_year」を「うるう年判定」操作の引数としてテストケース生成できていることが確認できる。
また、入力と出力の組合せが正しいことから、適切なテストケース生成ができていることが確認できる。

したがって、拡張したBWDMは、既存のBWDMの問題点である、操作のテストケース生成ができないという問題点を解決し、操作のテストケース生成ができることを確認できた。

\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption=拡張したBWDMに操作定義を含む仕様(コード\ref{fig:multiple_definition})を適用した際の出力,label=fig:extended_multiple_definition]

関数名 : うるう年判定
引数の型 : current_year:nat 
戻り値の型 : seq of (char)
生成テストケース数 : 17件(境界値分析:13/記号実行:4)

各引数の境界値
current_year : 4294967295 4294967294 0 -1 3 4 5 99 100 101 399 400 401 

記号実行情報
戻り値の数 : 4
制約 : current_year mod 400 = 0 and current_year mod 100 = 0and current_year mod 4 = 0, 戻り値 : "うるう年"
制約 : !( current_year mod 400 = 0 ) and current_year mod 100 = 0and current_year mod 4 = 0, 戻り値 : "平年"
制約 : !( current_year mod 100 = 0 ) and current_year mod 4 = 0, 戻り値 : "うるう年"
制約 : !( current_year mod 4 = 0 ) , 戻り値 : "平年"

境界値分析によるテストケース
No.1 : 4294967295 -> Undefined Action
No.2 : 4294967294 -> "平年"
No.3 : 0 -> "うるう年"
No.4 : -1 -> Undefined Action
No.5 : 3 -> "平年"
No.6 : 4 -> "うるう年"
No.7 : 5 -> "平年"
No.8 : 99 -> "平年"
No.9 : 100 -> "平年"
No.10 : 101 -> "平年"
No.11 : 399 -> "平年"
No.12 : 400 -> "うるう年"
No.13 : 401 -> "平年"

記号実行によるテストケース
No.1 : 400 -> "うるう年"
No.2 : 100 -> "平年"
No.3 : 4 -> "うるう年"
No.4 : 1 -> "平年"
    
\end{lstlisting}
\end{figure}

% 考察
\chapter{考察}\label{cha:Evaluation}
本章では、拡張したBWDMの有用性について考察し、関連研究と、拡張したBWDMの問題点について述べる。

\section{拡張したBWDMの有用性について}
本節では、拡張したBWDMの有用性についての考察を述べる。

\subsection{水準の積が膨大となるテストケース生成の比較検証}

\lstset{language=}
\begin{figure}[tp]
  \begin{lstlisting}[caption={因子が7で水準が$(6, 8, 6, 8, 8, 6, 6)$の関数を持つVDM++仕様},label=fig:pict4javaIndication]
class ProblemClass
functions

problemFunction : nat*nat*nat*nat*nat*nat*nat -> seq of char
  problemFunction(a, b, c, d, e, f, g) ==
    if(a > 4) then
      if(b mod 10 = 3) then
        if(c < 13) then
          if(b > 11) then
            "a>4 and b>11 and c<13"
          else
            if(g < 11) then
              "g<11"
            else
              "a>4 and b>10 and c<13"
        else
          if(d > 10) then
            "d>10"
          else
            if(e < 10) then
              "e<10"
            elseif(f > 10) then
              "f>10"
            else
              "a>4 and b>10 and c>=13"
      else
        "a>4 and b<=10"
    else
      "a<=4";
end ProblemClass
\end{lstlisting}
\end{figure}

\begin{table}[tp]
  \begin{center}
    \caption{因子が7で水準が(6, 8, 6, 8, 8, 6, 6)の関数を持つVDM++仕様(コード\ref{fig:pict4javaIndication})のテストケース生成結果の比較}
    \label{tab:pict4java_result}
    \begin{tabular}{c|c|c}
                   & 生成テストケース数 & 実行時間(秒) \\
      \hline
      \hline
      既存のBWDM   & 663,552            & 6.767146152  \\ \hline
      拡張したBWDM & 78                 & 0.88973152
    \end{tabular}
  \end{center}
\end{table}

本研究で拡張したBWDMが、既存のBWDMに比べて、テストケース総数を削減できることを確認する。
膨大な数のテストケースを生成するために、因子が7で水準が(6, 8, 6, 8, 8, 6, 6)の関数を持つVDM++仕様を、既存のBWDMと拡張後のBWDMにそれぞれ適用する。
適用したVDM++仕様を、コード\ref{fig:pict4javaIndication}に示す。
また、生成結果の比較を、表\ref{tab:pict4java_result}に示す。
実行環境は、macOS 10.13.6(CPU: Intel Core i5 2.3GHz, RAM: 16GB)である。
比較に用いる式を、以下に示す。

\begin{equation}\label{equ:sakugennritu}
  削減率(\%) = \frac{A - B}{A} \times 100
\end{equation}

\begin{center}
  A: 既存のBWDMによって生成したテストケース総数\\
  B: 拡張したBWDMによって生成したテストケース総数\\
\end{center}

表\ref{tab:pict4java_result}および式(\ref{equ:sakugennritu})より、生成テストケース数を$(663552-78)/663552 \times 100=99.98(\%)$削減できた。
既存のBWDMでは、膨大な数のテストケースを生成したのに対して、拡張後のBWDMでは、実用的な数のテストケースを生成した。

したがって、拡張後のBWDMは、境界値分析結果から生成するテストケース数が組合せ爆発を起こす可能性を排除できたと言える。
また、表\ref{tab:pict4java_result}から、テストケース生成時間についても86.85\%短縮できた。
以上から、拡張後のBWDMは実用性が高いと言えることから、BWDMは有用性が向上したと考える。

\subsection{人手によるドメイン分析テストのためのテストケース作成との比較検証}\label{sec:domain_exam}

人手によるドメイン分析テストのためのテストケース作成と、拡張したBWDMによるドメイン分析テストのためのテストケース生成で、作成(生成)に要した時間の比較検証を行った。
その結果を、表\ref{tab:time}に示す。

対象としたVDM++仕様は、\ref{cha:domain}節で用いた コード\ref{fig:vdm_park}である。
``割引価格となる''を期待出力に持つドメインに対するドメイン分析テストのためのテストケースを作成する時間を計測した。
生成するテストケースとしては、以下を基準とした。
\begin{enumerate}
  \item onポイント、offポイント、inポイント、outポイントを出力(記述)する
  \item onポイント、offポイント、outポイントには、着目条件式も出力(記述)する
  \item offポイントには、着目変数も出力(記述)する
  \item 各ポイントには、期待出力と正常系であるかどうかも出力(記述)する
\end{enumerate}

検証に参加したメンバーは本研究室の大学院生3人と学部4年生1人であり、
普段からソースコードの読み書きを行い、基本的なプログラミングの知識を有している。
VDM++の文法の知識を持たない者も含まれるが、
今回の検証に必要な文法は、事前に他のVDM++の例を用いてレクチャーした。
また、ドメイン分析テストのためのテストケース生成についても、事前に他のVDM++仕様とテストケースの例を用いてレクチャーした。

人手による検証では、
コード\ref{fig:vdm_park}を印刷した紙を渡し、
仕様を確認後、
テストケースを書き始めてから、テストケースを記述し終えるのに要した時間を計測した。
入力データと戻り値の組合せが不正確な場合、間違いを指摘し、
被験者が正しい組合せを記述した時点で時間計測終了とした。
また、制限時間を30分とし、制限時間を超えた場合、その場で時間計測終了とした。

拡張したBWDMによる検証では、
コマンドライン上での命令操作で、拡張したBWDMによるテストケース生成を行うのに要した時間を計測した。
また、実験に用いたコンピュータは、OS:macOS 10.14.5、CPU:2.3GHz Intel Core i5、メモリ:16GBである。

なお、JavaのSystem.nanoTime\cite{nanotime}メソッドを用いて、
命令操作を省いた純粋なテストケース生成処理にBWDMが要した時間を計測した結果、
1.25秒であった。

人手による作成と比較した結果、平均で18分程の時間短縮を確認できた。
対象にしたVDM++仕様には、VDM++独特の文法等は含まれないため、
VDM++に対する慣れなどの影響は無視できるものと思われる。
また、人手によるテストケース生成の場合、ヒューマンエラーも見られた。
具体的には、offポイントの記述時に、条件式の解釈を間違え、誤った期待出力を記述してしまった。(例：入力(17、 20)の期待出力を``遊園地チケットは割引価格とならない。(妻の年齢 $<$ 16)''と記述した。)
仕様の規模が拡大すると、人手とコンピュータとの処理効率の差に加えて、
ヒューマンエラーの有無などにより、テストケース生成に要する時間の差は更に拡大していくと思われる。
以上から、拡張したBWDMは有用性が向上したと考える。

\begin{table}[tp]
\centering
\caption{コード\ref{fig:vdm_park}のドメイン分析テストのためのテストケース作成に要した時間の比較}
\label{tab:time}
\begin{tabular}{cc}
\begin{minipage}[c]{0.5\hsize}
  \centering
  \begin{tabular}{c|c}
    被験者  & 時間              \\
    \hline
    \hline
    被験者A & 8m 16s            \\ \hline
    被験者B & 10m 23s           \\ \hline
    被験者C & 30m(制限時間超過) \\ \hline
    被験者D & 24m 04s
  \end{tabular}
\end{minipage} &
\begin{minipage}[c]{0.5\hsize}
  \centering
  \begin{tabular}{c|c}
                 & 時間    \\
    \hline
    \hline
    被験者(平均) & 18m 10s \\ \hline
    BWDM         & 0m 15s
  \end{tabular}
\end{minipage}
\end {tabular}
\end{table}


\subsection{複数定義対応に関する評価}
拡張したBWDMでは、複数の関数のテストケースを生成できるようになり(\ref{sec:tekiyou_multi_func}節参照)、また、定数定義ブロックで定義した定数を、関数定義や操作定義内で参照できるようになった(\ref{sec:tekiyou_value}節参照)。
加えて、インスタンス変数を含む操作定義のテストケースを生成できるようになった(\ref{sec:tekiyou_operation}節参照)。

これにより、BWDMの対応範囲が広がり、より多くのVDM++仕様のテストケース生成が可能となった。
したがって、拡張したBWDMの有用性が向上したと考える。


\section{関連研究}
\begin{comment}
\begin{figure}[t]
  \begin{center}
    \includegraphics[width=8cm]{image/model_park.png}
    \caption{設計モデルの例(遊園地チケット購入機能)}
    \ecaption{Example of design model (amusement park ticket discount function)}
    \label{fig:model_park}
  \end{center}
\end{figure}
\end{comment}

ドメイン分析に基づいたテストケースを自動生成する手法としては、丹野らの研究\cite{sekkeiModel}がある。
この手法では、変数同士に依存関係がある場合でも、制約ソルバ\cite{sat}を用いることで、依存関係を考慮した境界値等のテストケースを網羅的に生成する。
入力として、ソフトウェアの設計情報をモデル化した設計モデルと呼ばれるテキストを入力する必要がある。
%この設計モデルの例を、\figref{fig:model_park}に示す。これは、\figref{fig:vdm_park}の仕様から設計モデルを作成した例である。
設計モデルは\cite{sekkeiModel}で定義されている。

設計モデルは、仕様書を元に人手で記述する必要があるため、設計モデルの作成に時間と手間がかかってしまうという問題がある。
これに対して、拡張したBWDMは、VDM++仕様を元に、自動でテストケースを生成できるため、設計モデルを作成する必要がないという利点がある。
しかし、仕様書が自然言語のみで記述されている場合、VDM++仕様を記述しなければ、拡張したBWDMを使うことができない。
そのため、自然言語で記述された仕様書からドメイン分析テストのためのテストケースを作成する場合、設計モデルを記述するか、VDM++仕様を記述するかで対応が分かれることとなる。
なお、設計モデルの記述とVDM++仕様の記述に必要な要素がほぼ同じなため、記述量はほとんど変わらないと考える。
設計モデルは丹野らの手法でしか利用できないが、VDM++仕様を用いた場合は、BWDM以外にも、VDMTools\cite{vdmtools}やOverture IDE\cite{overture}などの支援ツールが揃っており、仕様の検証や記述を行いやすいという利点がある。

\section{拡張した\tool{}の問題点}
以下に、今回拡張したBWDMの問題点を示す。

\begin{itemize}
  \item 整数型以外の型に対応していない\\
        拡張したBWDMは、整数型である、int型とnat型とnat1型のみにしか対応していない。
        実数値を表すreal型や有理数を表すrat型、複数の型から構成される
        合成型などには対応していない。そのため、それらを
        用いた仕様からテストケースを作成できない。
        それらの未対応の型への対応は、VDM++仕様を静的解析する際に型情報を読み込み、
        境界値分析時に、読み込んだ型情報から境界値の生成処理をBWDMに追加することによって、解決可能であると考える。

  \item 型定義に対応していない\\
        拡張したBWDMは、型定義ブロックに記述した型定義を用いた関数や操作のテストケースを生成できない。
        この問題は、型定義部で定義した型について静的解析を行い、
        境界値分析を行う処理の際に、それらの情報を用いて境界値を生成することで、
        解決可能であると考える。

  \item 関数定義と操作定義内で対応している構文が少ない\\
        拡張したBWDMは、if条件式境界値の生成をVDM++仕様の関数定義内のif-then-else式のみから行っており、それ以外の構文には対応していない。
        また、if条件式も、不等号($<、<=、>、>=$)と剰余($mod$)のみの対応である。
        if-then-else式同様に、条件と動作の記述が可能なcases式などに対応していないため、
        ツールの適用可能な範囲はまだ狭く、実用性が高いとは言えない。
        この問題は、新たな構文への対応のために、新たな構文の情報抽出方法と、境界値分析手法の提案を行うことで解決可能であると考える。

  \item インスタンス変数を操作する操作定義のテストケースを生成できない\\
        拡張したBWDMは、インスタンス変数を操作する操作定義のテストケース生成ができない。
        なぜなら、if-then-else式を使用していない操作の入力と期待出力を推定できないからである。
        この問題は、インスタンス変数定義ブロック内で定義した不変条件に対応することで解決可能と考える。
        具体的には、不変条件を元に生成した境界値を入力とし、不変条件を満たすかどうかの真偽値を期待出力とするテストケースを生成することで、インスタンス変数を操作する操作定義のテストケースを生成できると考える。

        %\item 事前条件と事後条件に考慮したテストケースの生成ができない\\
        %      拡張したBWDMは、事前条件(\ttt{pre})と事後条件(\ttt{post})に対応していないため、事前条件と事後条件に考慮したテストケースの生成ができない。
        %      この問題は、事前条件
  \item 他の関数または操作を呼び出す関数定義と操作定義のテストケースを生成できない\\
        拡張したBWDMでは、他の関数または操作を利用する関数定義と操作定義のテストケースを生成できない。
        この問題は、抽象構文木解析処理において解析した関数、および、操作をJavaコードに変換し、スタックを構築して関数呼び出しの仕組みを作ることで解決可能と考える。
\end{itemize}

% おわりに
\chapter{おわりに} \label{cha:Conclusion}
本研究では、BWDMの有用性の向上を目的として、BWDMの拡張を行った。
具体的には、既存のBWDMが持つ5つの問題点を解決した。
また、拡張後のBWDMの名称を\tool{}(\toolFullName{})に変更した。
本研究で解決した5つの問題点を、下記に示す。

\begin{enumerate}[label=(\alph*)]
  \item 境界値分析時にすべての組合せを用いてテストケースを生成するため、組合せ爆発を起こす可能性がある
  \item 複数の変数を含む条件式を持つ関数のテストケースを生成できない
  \item 1つの関数しかテストケースを生成できない
  \item 定数定義ブロック内の定義を含む関数を含む仕様のテストケースを生成できない
  \item 操作のテストケースを生成できない
\end{enumerate}

上記5つの問題点を解決するために、既存のBWDMに、以下の3つの機能拡張を行った。

\begin{itemize}
  \item ペアワイズ法の適用によるテストケース数削減
  \item ドメイン分析テストの適用による複数変数を含む条件式を含む関数のテストケース生成
  \item 複数の定義への対応
\end{itemize}

まず、既存のBWDMにおける、境界値分析結果から生成するテストケース数が組合せ爆発を起こす可能性(問題\ref{problem:1})の排除を目的として、BWDMの拡張を行った。
拡張したBWDMは、VDM++仕様に対して境界値分析を行い、ペアワイズ法を適用し、テストケースを自動生成する。
これにより、境界値分析結果から生成するテストケース数が組合せ爆発を起こす可能性を排除することができ、テスト工程の作業効率化を見込めると考えられる。

次に、本研究では、既存のBWDMにおける、複数の変数を含む条件式を持つ仕様に対してテストケース生成ができないという問題(問題\ref{problem:2})の解決を目的として、ドメイン分析テストのためのテストケース生成を、BWDMに適用する拡張を行った。
まず、複数の変数を含んだ条件式を解析できるように、構文解析部を拡張した。
次に、ドメイン分析部を追加し、onポイント、offポイント、inポイント、outポイントを生成できるようにした。
また、SMTソルバを用いて、充足可能性問題を解けるようにした。
さらに、テストケースに、正常系判定値、着目条件式、そして着目変数の情報を含めるために、テストケース生成部を拡張した。
今回の拡張により、既存のBWDMでは生成できなかった、複数の変数を含む条件式を持つVDM++仕様の構文解析と、ドメイン分析テストのためのテストケース生成ができるようになったことを確認した。
また、20行ほどのVDM++仕様に対して、ドメイン分析テストのためのテストケース生成に要した時間を人手と比較検証した結果、18分程の時間短縮を確認できた。

加えて、本研究では、既存のBWDMにおける、
1つの関数しかテストケースを生成できないという問題(問題\ref{problem:3})、
定数定義ブロック内の定義を含む関数を含む仕様のテストケースを生成できないという問題(問題\ref{problem:4})、
操作のテストケースを生成できないという問題(問題\ref{problem:5})の解決を目的として、
BWDMにおける構文解析部の抽象構文木解析処理を修正し、BWDMを拡張した。
これにより、BWDMの対応範囲が広がり、より多くのVDM++仕様のテストケース生成が可能となった。

以上により、本研究で行った拡張によって、
既存のBWDMが持つ5つの問題点を解決し、BWDMの有用性が向上したと言える。
また、BWDMがテストケースを自動生成できるVDM++仕様の構文が増えたことにより、テストケース作成作業の自動化率が向上するため、テスト工程の作業効率が向上したと言える。

以下に、今後の課題を示す。

\begin{itemize}
  \item 整数型以外の型への対応\\
        現状、実数を表すreal型や、有理数を表すrat型、複数の型から構成する合成型などの、VDM++の多くの型に未対応である。
        この問題は、VDM++仕様を静的解析する際に型情報を読み込み、
        境界値分析時に、読み込んだ型情報から境界値の生成処理をBWDMに追加することによって、解決可能であると考えられる。

  \item 型定義の対応\\
        拡張したBWDMは、型定義ブロックに記述した型定義を用いた関数や操作のテストケースを生成できない。
        この問題は、型定義部で定義した型について静的解析を行い、
        境界値分析を行う処理の際に、それらの情報を用いて境界値を生成することで、
        解決可能と考える。

  \item 関数定義と操作定義内で利用できる構文の対応範囲拡大\\
        拡張したBWDMは、if条件式境界値の生成をVDM++仕様の関数定義内のif-then-else式のみから行っており、それ以外の構文には対応していない。
        この問題は、対応していない構文の情報抽出方法と、境界値分析手法の提案を行うことで解決可能と考える。

  \item インスタンス変数を操作する操作定義のテストケースの生成への対応\\
        拡張したBWDMは、インスタンス変数を操作する操作定義のテストケース生成ができない。
        この問題は、インスタンス変数定義ブロック内で定義した不変条件に対応することで解決可能と考える。

  \item 他の関数または操作を呼び出す関数定義と操作定義のテストケース生成への対応\\
        拡張したBWDMでは、他の関数または操作を利用する関数定義と操作定義のテストケース生成ができない。
        この問題は、抽象構文木解析処理において解析した関数、および、操作をJavaコードに変換し、スタックを構築して関数呼び出しの仕組みを作ることで解決可能と考える。
\end{itemize}

%%
% 謝辞
%
\acknowledgment{}
本研究において、数多くのアドバイス、叱咤激励、知識、そして食料の差し入れをいただきました、
宮崎大学工学教育研究部の片山徹郎教授に、心から感謝申し上げます。

また、本論文の執筆にあたり、時にはユーモアを交え、貴重なご意見とご指摘を頂きました、
宮崎大学工学教育研究部の山森一人教授と油田健太郎准教授に、深く感謝いたします。

そして、既存のBWDMについての知識、ノウハウを教えていただいた、
偉大なるBWDMの生みの親、立山博基氏に、次あったときにありがとうございましたとお伝えしたいです。

他にも、何の知識もない私に、技術的知識、研究とは何かなどの、さまざまなことを教えていただき、
時には、アニメ鑑賞会、漫才、ジョイフルを共に行っていただいた、
片山徹郎研究室の偉大なる先輩、偉大なる同輩、偉大なる後輩の皆様、ありがとうございました。
皆様のおかげで、辛いとき、悩めるときも、前向きに生活することができました。

最後に、私を成長させてくれた、すべての方々、本当にありがとうございました。
6年間という長い長い大学生活を、とても満足のいくものとすることができました。
胸を張って修了できます。

%%
% 参考文献
%
\bibliography{master} %hoge.bibから拡張子を外した名前
\bibliographystyle{junsrt} %参考文献出力スタイル

%%
% 付録
%
% \appendix{} % 付録は基本的に使わない

\end{document}
